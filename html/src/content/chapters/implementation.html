<h1 id="chapter:implementation">Implementacja</h1>

<p>
    Niniejszy rozdział stanowi uzupełnienie do rozdziału <a href="#chapter:solution"></a>, wyjaśniające zasadę działania
    ważniejszych elementów proponowanego w tej pracy rozwiązania problemu płynnej i nieograniczonej wizualnej
    eksploracji danych pomiarowych.
</p>
<p>
    Właściwa implementacja wspiera:
</p>
<ul>
    <li>wyświetlanie wielu komponentów wykresów jednocześnie,</li>
    <li>wyświetlanie tej samej serii danych w różnych wykresach, w dowolnych zakresach,</li>
    <li>wyświetlanie wielu serii na jednym wykresie.</li>
</ul>

<p>
    By wydajnie wspierać powyższe funkcje, <em>ExporeJS</em> maksymalizuje współdzielenie zasobów:
</p>
<ul>
    <li>wszystkie zapytania o dane do serwera są zarządzane przez jeden moduł <em>ReqestManager</em>,</li>
    <li>moduł <em>CacheManager</em> powiela moduł <em>SerieCache</em> dla każdej serii danych,</li>
    <li>moduł <em>DataSource</em> tworzony jest dla każdego komponentu wykresu osobno.</li>
</ul>

<p>
    Diagram <a href="#picture:architecture"></a> pokazuje przykładowe ustawienie modułów dla aplikacji z trzema
    wykresami, gdzie pierwszy oraz trzeci wyświetlają dane z tej samej serii danych pomiarowych.
</p>

<p>
    Każdy komponent wykresowy podłączony jest do swojego <em>DataSource</em> poprzez adapter specyficzny dla danego typu
    komponentu (oznaczony symbolem interfejsu).
    Informuje o interakcji użytkownika oraz przyjmuje nowe dane do aktualizacji.
</p>

<p>
    Każda instancja <em>DataSource</em> posiada inny zestaw modeli predykcji, w związku z czym silnik predykcji, zawarty
    w każdej instancji <em>DataSource</em> może reagować na interakcję użytkownika inaczej.
    Każda z siedmiu instancji modelu predykcji niezależnie odwołuje się do pamięci podręcznej tej serii danych, którą
    obsługuje powiązany <em>DataSource</em>.
</p>

<p>
    Wewnątrz instancji <em>DataSource</em> umieszczone są instancje <em>DynamicProjection</em>, które szczegółowo
    opisane są w dalszej części tego rozdziału.
</p>

<p>
    Moduł <em>CacheManager</em> zarządza instancjami <em>SerieCache</em>, których zadaniem jest obsługa wielowarstwowej
    pamięci podręcznej oraz jej projekcji, opisanej w rozdziale <a href="#chapter:multilayer-cache"></a>.
</p>

<p>
    Moduł <em>RequestManager</em> obsługuje żądania z pamięci <em>cache</em> wszystkich serii danych, grupuje je w
    większe paczki, wysyła je do serwera danych, a odpowiedź rozpakowuje i rozsyła do adektwatnych instancji <em>SerieCache</em>.
</p>

<p>
    Serwer REST implementuje uzgodniony format zapytania, odpytuje serwer danych lub bezpośrednio bazę danych.
</p>


<figure type="picture" id="picture:architecture">
    <figcaption>Diagram pokazujący zwielokrotnienie modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/client-architecture.png">
</figure>



<h2>Komunikacja z serwerem REST</h2>


<!--


<p>
implementacja: Debounce do gromadzenia zapytań do serwera, opisać merging batch
</p>
<p>
    Proponowane rozwiązanie, ExploreJS jest niezależne od wykorzystywanego oprogramowania po stronie serwera.
    W związku z tym, dla każdego wskazanego serwera konieczne jest jego zintegrowanie poprzez implementację określonego
    interfejsu zapytania i odpowiedzi.
</p>
<h3>
    Interfejs HTTP JSON
</h3>
<p>
Do komunikacji HTTP z serwerem został wybrany format JSON.
Przy definiowaniu standardu należy zwrócić, uwagę, że w aplikacji użytkownika możliwe jest jednoczesne występowanie
wielu instancji komponentów wizualizacji danych. Mowa tutaj o przeglądaniu wielu serii na jednym wykresie, czy o
widokach typu panel kontrolny <span trans="ang">Dashboard</span>.
W takiej sytuacji wiele żądań jest wysyłanych jednocześnie.
</p>
<p>
    Aby minimalizować liczbę jednoczesnych zapytań, wszystkie żądania do serwera pochodzące z tej samej aplikacji pakuje
    się w jedną paczkę.
    W związku z tym interfejs serwera zdefiniowany jest tak, by zwracał w jednej odpowiedzi dane z różnych serii,
    na różnym poziomie abstrakcji, z różnego okresu czasu.
    Na listingu <a href="#code:request-format"></a> pokazano przykładowe zapytanie HTTP JSON do serwera.
    Jest to lista fragmentów danych opisanych identyfikatorem serii, poziomem abstrakcji (agregacją) oraz okresem czasu.
    Odpowiedź serwera pokazana na listingu <a href="#code:response-format"></a> zawiera listę punktów serii danych
    określonych w parametrach zapytania.
</p>
<p>
    W proponowanym formacie zapytania i odpowiedzi użytko nazwanych atrybutów dotyczących skali danych.
    Serwer danych udostępnia dane w skali dyskretnej, na przykład w agregacjach minutowych, godzinnych, dobowych,
    czy 30-dniowych.
    Jednak, z punktu widzenia eksploracji w wizualnej analizie, nie jest istotne, aby skale były ułożone
    zwyczajowo (doba, miesiąc, tydzień).
    Równie dobrze serwer może używać agregacji równych, czyli takich, gdzie kolejne agregacje są k-krotnością
    poprzedniej, na przykład: 1s, 4s, 16s, 64s, (...). W tej sytuacji na dwunastym poziomie otrzymuje się agregację
    dwuletnią. Podobne podejście stosuje się w rozłożeniu poziomów dyskretnej skali w systemach mapowych
    <a href="#bib:sample2010tile" chapter="2.2 Global Logical Tile Scheme"></a>.
</p>
<p>
    TODO która skala jest mała ktora duża
    Aby nie uzależniać kodu klienta od struktury danych serwera, serwer udostępnia dodatkową informację, tzw.
    <i>manifest</i>. Aplikacja kliencka podczas inicjalizacji pobiera manifest aby wiedzieć, z jakich skal może
    skorzystać. Na listingu <a href="#code:manifest-format"></a> przedstawiono przykładowy manifest serwera. W tym
    przypadku dane surowe są zbierane co około 10 sekund, natomaist najmniejsza skala agreguje dane w okresie 120 dni.
</p>

<figure type="code" id="code:request-format">
    <figcaption>Format zapytania o dane</figcaption>
    <code class="javascript">
        { series: [
        { id: 'serie001', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
        { id: 'serie002', 'level': 'raw', from: '2016-01-27 06:00', to: '2016-01-27 06:04' },
        { id: 'serie001', 'level': '1h',  from: '2016-01-01 12:00', to: '2016-02-23 12:00' },
        { id: 'serie003', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
        { id: 'serie003', 'level': '1d',  from: '2016-01-23 00:00', to: '2016-01-26 00:00' }
        ]}
    </code>
</figure>


<figure type="code" id="code:response-format">
    <figcaption>Format odpowiedzi serwera</figcaption>
    <code class="javascript">
        { series: [
        { id: 'serie001', 'level': '1m',
        from: '2016-01-23 13:05' to: '2016-01-23 17:57',
        data: [
        { @: '2016-01-23 13:05', a: 312.3, t: 404.1, b: 300.9 },
        { @: '2016-01-23 13:06', a: 312.7, t: 377.0, b: 300.1 },
        { @: '2016-01-23 13:07', a: 301.5, t: 304.2, b: 224.8 },
        ...
        { @: '2016-01-23 17:56', a: 813.3, t: 888.0, b: 813.1 },
        { @: '2016-01-23 17:57', a: 900.3, t: 903.1, b: 813.9 },
        ]
        },
        { id: 'serie002', 'level': 'raw',
        from: '2016-01-27 06:00', to: '2016-01-27 06:04',
        data: [
        { $: '2016-01-27 06:00:23', v: 33 },
        { $: '2016-01-27 06:00:27', v: 33 },
        { $: '2016-01-27 06:00:34', v: 34 },
        ...
        { $: '2016-01-27 06:04:23', v: 37 },
        { $: '2016-01-27 06:04:35', v: 37 },
        ]
        },
        ...
        ]}
    </code>
</figure>

<figure type="code" id="code:manifest-format">
    <figcaption>Format manifestu serwera</figcaption>
    <code class="javascript">
        {
        "series": [
        {
        "serieId": "s001",
        "start": 1448060400000,
        "end": 1448881190000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "30s", "step": 30000 },
        ...
        { "id": "120d", "step": 10370000000 }
        ]
        },
        {
        "serieId": "s002",
        "start": 1451602800000,
        "end": 1454324390000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "30s", "step": 30000 },
        ...
        { "id": "120d", "step": 10370000000 }
        ]
        },
        {
        "serieId": "s003",
        "start": 1448060400000,
        "end": 1448881190000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "1m", "step": 60000 },
        ...
        { "id": "100d", "step": 86400000000 }
        ]
        }
        ]
        }
    </code>
</figure>



-->


<h2>algebra przedziałów i operacje przekształcające</h2>
<p note="opisać operacje sum sub, and, etc, że jego wyjściem jest instrukcja diff">
    dodatkowo wspomnieć o bisekcji, żeby operować tylko na małym fragmencie
    opisać gdzie występowała konieczność diffów różnorakich zbiorów (cache projection, dynamic projection recompile,
    levelCache.requestRange()...
</p>

<!--


wizualizacja operacji https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_15

<p helper="przeniesiono z architektury">
    Rozwiązanie <em>ExploreJS</em> można podzielić koncepcyjnie na moduły, które dodatkowo klasyfikują się na trzy
    kategorie
    ze względu na ich liczebność.

    Zwielokrotnienie modułów wynika z faktu, że zaproponowane rozwiązanie wspiera maksymalne współdzielenie zasobów przy
    wyświetlaniu wielu wykresów jednocześnie, na których może być wyświetlane wiele serii danych pomiarowych, a ta sama
    seria danych może być pokazywana na różnych wykresach.

    Można tutaj przywołać przykład aplikacji, w której użytkownik porównuje dane meteorologiczne w ten
    sposób, że wyświetla trzy wykresy, każdy z nich jest przesunięty względem siebie o jeden rok, a na każdym
    wyświetlane jest 6 tych samych serii pomiarowych.

    W tym przypadku rozwiązanie będzie współdzieliło zoptymalizowany kanał komunikacyjny, ale również pamięć cache dla
    każdej z 6 serii.
</p>-->




<h2>Przeliczanie projekcji</h2>

<p note="ten algorytm Front, Back, THIS, i tak dalej"></p>


<!--


fajny rysunek: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_89

zainspirować się błędnym, ale zrobionym diagramem: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_8

nawiązać do frameworków react i angular w kwestii obliczania diffów do efektywnego zarządzaniem UI.
        Nie możemy po prostu liczyć diffów z całego zbioru (tak jak to robi react) w celu przebudowania UI, musimy
        liczyć diff w locie.
        React źle znosi liczenie wielkich diffów (gdyby w ten sposób deklarować renderowanie big data).
        Big data - cache może być wielki (długo działająca aplikacja), więc przeliczanie diffow nie wchodzi w rachubę.

<pre>
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓        ┏━━━━━┓        ┏━━━━━┓        │
    │   1     2        3     4        5     6        │
    ├ T                                              │
    │                                                │
    ├ B                                              │
    │                                                │
    ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
    │   0                                         7  │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 1 2 3 4 5 6 │
    ├ T ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    ├ B │
    │ │
    ├ R ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    └────────────────────────────────────────────────┘
</pre>
<figure type="code" id="code:demo1">
    <pre>
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T                                              │
        │                                                │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
        │   0                                         7  │
        └────────────────────────────────────────────────┘
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        └────────────────────────────────────────────────┘
    </pre>
</figure>



<p helper="z konwersacji">
    [11:47 AM] Adam Borowski [Atlassian]: algorytmy ktore mi zajely duzo czasu to operacje UNION oraz SUBTRACT na takiej
    strukturze jak zbiór przedziałów (interval set).
    Same operacje są banalne, i są biblioteki na to, ale to co stanowi wyzwanie to obliczenie kroków transformacji
    pierwszego zbioru, aby stał się tym drugim  ( w czasie liniowym). To jest rodzaj algorytmu DIFF ale tworzony podczas
    wykonywania samej operacji UNION i SUBTRACT.
    Przykładowy test który może to ilustruje:
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('0 1 1 10'), rng('2 6 9 10 13 20'))).to.deep.equal({
    added: rng('6 9'),
    removed: [],
    resized: rng('[1 10->2]'),
    result: rng('[0 1] [1 10->2] 6 9')
    });
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('2 6 7 17 18 28'), rng('0 7 7 12 12 13'))).to.deep.equal({
    added: [],
    removed: rng('2 6'),
    resized: rng('[7->13 17]'),
    result: rng('[7->13 17] [18 28]')
    });
    [11:50 AM] Adam Borowski [Atlassian]: rysuneczek dla operacij C=A-B
    [11:50 AM] Adam Borowski [Atlassian]:
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 4 7 10 20 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ │
    │ 2 8 10 13 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 13 20 │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
    [11:52 AM] Adam Borowski [Atlassian]: w tym przypadku algorytm zwraca oprocz samego wyniku C=A-B inofrmacje:
    [1 2] pozostaje bez zmian
    [4 7] rozszerza się do [2 8]
    [10 20] zwęża się do [13 20]
    [11:53 AM] Adam Borowski [Atlassian]: sorki ze Ci spamuje ale jak juz tlumacze to te notatki sobie wkleje roboczo do
    magisterki zeby z tego podrozdzial zrobic
    [11:56 AM] Adam Borowski [Atlassian]: oczywiscie to dziala dla wszystkich case, na przykład gdy przedział z B
    rozdziela jeden przdział z A na dwa przedziały
    [11:56 AM] Adam Borowski [Atlassian]:
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 11 14 15 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━┓ │
    │ 2 7 9 11 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 2 7 9 14 15 │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
    [12:00 PM] Adam Borowski [Atlassian]: a odpowiedź algorytmu taka:
    [12:00 PM] Adam Borowski [Atlassian]:
    {
    "result": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    },
    {
    "start": 7,
    "end": 9
    },
    {
    "start": 14,
    "end": 15,
    "existing": {
    "start": 14,
    "end": 15
    }
    }
    ],
    "added": [
    {
    "start": 7,
    "end": 9
    }
    ],
    "removed": [],
    "resized": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    }
    ]
    }
</p>


-->

<h2>Adapter komponentu wykresu</h2>
<p note="chodzi o wykresy i ich aktualizacje oraz interfejsy <q>patch</q> (visjs) i <q>replace</q> (flot)">
    (pseudokod adaptera?)
</p>

<!--

TODO: rozważanie o sposobie powiadamiania klienta o zmianach danych
<ul>
    <li>powiadomienie, że gdzieś coś się zmieniło, wtedy użytkownik albo sam robi diffa, albo resetuje komponent
        wykresów. to może powodować bad UX, migotanie, itd
    </li>
    <li>powiadomienie o dokładnych zmianach. instrukcja co krok po kroku należy zmienić, aby przejść ze stanu obecnego
        do wyjsciowego. minimalizacja liczby kroków.
        Jaki fragment danych z wykresu usunąć ( z jakiej warstwy).
        Jaki fragment danych z wykresu poszerzyć (z jakiej warstwy).
        Jaki fragment do danych z wykresu dodać (z jakiej warstwy).
        Common pattern byłby taki, że albo każda seria to inna warstwa, albo jedna seria ma punkty ze wszystkich warstw.
    </li>
</ul>
<figure type="code">
    <code class="javascript">
        class ExampleZingAdapter extends ClientProxyAdapter{
        processChange(diff) {
        // diff.added, diff.removed, diff.resized -- > {layer:[Number], start, end}
for(var removedRange of diff.removed){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
for(var addedRange of diff.added){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
}
}
</code>
</figure>
-->


<p helper="">
    problemy implementacyjne https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_27
</p>


<h2>Wraper dla agregacji</h2>

<!--
Konieczność wrapperdisplay cache i translacja data-projection-data

implementacja: Skale zwyczajowe (użytkowe np dzień 12, tydzień 53, miesiąc, etc) nie robią problemu u mnie, bo każda
            agregacja ma parametr czas otwarcia i czas zamknięcia okresu który reprezentują. Żadną agregacja nie musi
            być wielokrotnościa poprzedniej, bo punkty agregacji są niezależne pomiędzy warstwami.
            Dopiero CacheProjection dobiera sobie agregację do zakresów czasu, ale znowu, każda agregacja ma wpisany
            czas za który odpowiada.
-->

<h2>Problemy z integracją z bibliotekami</h2>
<ul>
    <li>ZingChart
        * obfuscowany kod, debugging, errory...
        * beznadziejne API globalnych komend, nie da się niektórych rzeczy łatwo uzyskać ustawić
        * chyba wypełniad dziury między date.getTime() a date.getTime() co trwa bardzo długo... alokacja kilkadziesiat sekund - nie można przyczyny normalnie zdebugować
        * brak normalnego pan&zoom
        * jakieś dziwne przeliczenia iteracja po dziedzinie co "1" - od jednej daty do drugiej może minąć dużo czasu -
        to jednoznacznie dyskwalifikuje - dzieje się to w momencie gdy następuje zmiana zakresu wyświetlanego
    </li>
</ul>
<h2>Wykorzystane narzędzia i środowiska</h2>

<p helper="prezentacja 2">
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_39
</p>
<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

</p>

<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>


<h2>Klasa Range</h2>

<p note="opisać wszystkie metody klasy Range  i po co mogą być potrzoebne"></p>

<h2>DynamicProjection</h2>

<p helper>

    przełączanie się,
    range scoped event
    opisać kafelkowanie zakresu danych (żeby predyktor nie doładowywał małych słupków podczas smooth paningu
    Nakładanie się warstw o dynamicznej zawartosci, jak w nakładaniu obrazów. Niemożliwe prxerysowywanie od
    początku, tylko minimalne fragmenty. Wyliczanie tych fragmentów stanowi trudność.
</p>

<h2>Modele predykcji</h2>

<p note="zaimplementowane modele predykcji" helper>
    implementacja: prediction models i dynamicProjection - paddingi, <strong>tiles</strong> muszą być sensownie dopasowane,
    żeby np wykres nie byl co chwile przerysowany, bo jakis drobnostkowy model predykcji co chwile aktualizuje
    mały kawałeczek
</p>
