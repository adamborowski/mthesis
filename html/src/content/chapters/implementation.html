<h1 id="chapter:implementation">Implementacja</h1>

<p>
    Niniejszy rozdział stanowi uzupełnienie do rozdziału <a href="#chapter:solution"></a>, wyjaśniające zasadę działania
    ważniejszych elementów proponowanego w tej pracy rozwiązania problemu płynnej i nieograniczonej wizualnej
    eksploracji danych pomiarowych.
</p>
<p>
    Zastosowanie biblioteki <em>ExploreJS</em> w praktyce pozwala na:
</p>
<ul>
    <li>wyświetlanie wielu komponentów wykresów jednocześnie,</li>
    <li>wyświetlanie tej samej serii danych w różnych wykresach, w dowolnych zakresach,</li>
    <li>wyświetlanie wielu serii na jednym wykresie.</li>
</ul>

<p>
    By wydajnie wspierać powyższe funkcje, <em>ExploreJS</em> maksymalizuje współdzielenie zasobów w ramach całej
    aplikacji w przeglądarce:
</p>
<ul>
    <li>wszystkie zapytania o dane do serwera są zarządzane przez jeden moduł <em>ReqestManager</em>,</li>
    <li>moduł <em>CacheManager</em> powiela moduł <em>SerieCache</em> (odpowiedzialny za pamięć podręczną serii i
        projekcje warstw) dla każdej serii danych,
    </li>
    <li>moduł <em>DataSource</em> tworzony jest dla każdego komponentu wykresu osobno.</li>
</ul>

<p>
    Diagram <a href="#picture:architecture"></a> pokazuje przykładowe ustawienie modułów dla aplikacji z trzema
    wykresami, gdzie pierwszy oraz trzeci wyświetlają dane z tej samej serii danych pomiarowych.
</p>

<p>
    Każdy komponent wykresowy podłączony jest do swojego <em>DataSource</em> poprzez adapter specyficzny dla danego typu
    komponentu (oznaczony symbolem interfejsu).
    Informuje o interakcji użytkownika oraz przyjmuje nowe dane do aktualizacji.
</p>

<p>
    Każda instancja <em>DataSource</em> posiada inny zestaw modeli predykcji, w związku z czym silnik predykcji, zawarty
    w każdej instancji <em>DataSource</em> może reagować na interakcję użytkownika inaczej.
    Każda z siedmiu instancji modelu predykcji niezależnie odwołuje się do pamięci podręcznej adekwatnej serii danych.
</p>

<p>
    Wewnątrz instancji <em>DataSource</em> umieszczone są instancje <em>DynamicProjection</em>, które szczegółowo
    opisane są w dalszej części tego rozdziału.
</p>

<p>
    Moduł <em>CacheManager</em> zarządza instancjami <em>SerieCache</em>, których zadaniem jest obsługa wielowarstwowej
    pamięci podręcznej oraz jej projekcji, opisanej w rozdziale <a href="#chapter:multilayer-cache"></a>.
</p>

<p>
    Moduł <em>RequestManager</em> obsługuje żądania z pamięci <em>cache</em> wszystkich serii danych, grupuje je w
    większe paczki, wysyła je do serwera danych, a odpowiedź rozpakowuje i rozsyła do adektwatnych instancji <em>SerieCache</em>.
</p>

<p>
    Serwer REST implementuje uzgodniony format JSON zapytania i odpowiedzi, odpytuje serwer danych lub bezpośrednio bazę danych.
</p>


<figure type="picture" id="picture:architecture">
    <figcaption>Diagram pokazujący liczebność instancji modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/client-architecture.png">
</figure>



<h2>Komunikacja z serwerem REST</h2>

<p>
    Biblioteka <em>ExploreJS</em> jest niezależna od wykorzystywanego oprogramowania po stronie serwera.

    Należy jednak pamiętać, że serwer danych musi udostępniać dane zagregowane w miarę równomiernie rozłożonymi
    poziomami agregacji, jak jest to opisane w rozdziale <a href="#chapter:data-reduction"></a>.

</p>

<p>
    Serwis REST udostępniać musi dwa zasoby.

    Ich ścieżka jest konfigurowalna podczas inicjalizacji <em>ExploreJS</em>.

    Pierwszym zasobem jest <code>GET /manifest</code>, drugim <code>POST /batch</code>.

    Tutaj nasuwa się pytanie, dlaczego serwis odczytujący dane obsługuje metodę <code>POST</code>, służącą zwyczajowo do
    dodawania nowych zasobów do serwera.

    Zapytanie <code>batch</code> zawiera dane w swoim ciele <trans lang="ang">request body</trans>.

    Mimo, że właściwa do tego zastosowania metoda <code>GET</code> oficjalnie wspiera <trans> request body</trans>, to
    implementacje wielu systemów się tego nie spodziewają.

    By uniknąć problemów z wycinaniem tej części zapytania przez systemy <em>firewall</em> lub mechanizm filtrów w <em>JAVA
    Enterprise</em>, stosuje się wyjątkowo metodę POST.
</p>

<h3>Manifest danych pomiarowych</h3>
<p>
    Podczas inicjalizacji <em>ExploreJS</em> w aplikacji w przeglądarce, do serwera zostaje wysłane zapytanie
    <code>GET /manifest</code>, które zawiera ważne z punktu widzenia biblioteki informacje o udostępnianych danych
    (pokazane na listingu <a href="#code:manifest"></a> ).
    Dla każdej serii danych pomiarowych zwracany jest:
</p>
<ul>
    <li>identyfikator serii,</li>
    <li>początek i koniec zakresu wszystkich dostępnych danych,</li>
    <li>informację o udostępnianych poziomach agregacji, gdzie dla każdego poziomu zdefiniowane są:
        <ul>
            <li>identyfikator agregacji,</li>
            <li>długość okresu agregowania.</li>
        </ul>
    </li>
</ul>

<figure type="code" id="code:manifest">
    <figcaption>Przykładowa odpowiedź manifestu danych</figcaption>
    <pre><code class="json">
{ "series":[
      {
         "start": 1317427200000, // 2011-10-01
         "end": 1496880000000,   // 2017-06-08
         "serieId": "AM01_NOX",  // stężenie tlenku azotu na stacji pomiarowej numer 1
         "levels":[
            { "id": "30s", "step": 30000 },
            { "id": "1m", "step": 60000 },
            [...]
            { "id": "90d", "step": 7776000000 },
            { "id": "1y", "step": 31536000000 }
         ]
      },
      [...]
] }</code></pre>
</figure>

<p>
    Dzięki manifestowi wiadomo, jakie są dostępne poziomy agregacji.
    Jest to niezbędne do wyznaczania odpowiedniego poziomu agregacji do wyświetlenia.
    Manifest również jest używany przez modele predykcji.
</p>

<p>
    Po pobraniu manifestu zostają utworzone instancje <em>SerieCache</em> odpowiedzialne za obsługę pamięci
    <em>cache</em> oraz jej projekcji.
</p>

<p>
    Ważne jest również to, że w celu uproszczenia rozwiązania, dane surowe są traktowane przez <em>ExploreJS</em>
    również jako agregacje danych. Z punktu widzenia działania mechanizmów wewnątrz <em>ExploreJS</em> nie ma
    rozróżnienia między danymi surowymi a agregacjami tych danych. Przyjmuje się, że dane surowe oznacza się
    identyfikatorem <q>raw</q> o długości agregowanego zakresu odpowiadającej średniej częstości zbierania tych danych.
    Dla danych monitoringu jakości powietrza będzie to okres <em>10s</em>, dla danych medycznych przykładowo
    <em>50ms</em>. Rozróżnienie danych surowych od agregacji jest istotne dopiero przy wyświetlaniu danych na wykresie,
    co zostało omówione w rozdziale <a href="#chapter:implementation-adapter"></a>.
</p>

<h3>Grupowe zapytania o dane</h3>

<p>
    Drugim typem zapytań są zapytania o same dane pomiarowe.

    Zapytanie jest tak naprawdę paczką zapytań, zgrupowanych przez moduł <em>RequestManager</em>.

    W ciele zapytania <code>POST /batch</code> znajduje się zbiór żądań o dane z różnych serii, różnych poziomów
    agregacji oraz różnych zakresów danych, jak pokazano na listingu <a href="#code:batch"></a>.
</p>

<figure type="code" id="code:batch">
    <figcaption>Przykładowe ciało grupowego żądania o dane</figcaption>
    <pre><code class="json">
[ {
    "id": "AM01_NOX",     // stężenie tlenku azotu na stacji pomiarowej numer 1
    "level": "1h",        // agregacje godzinne
    "from": 772088888908, // zakres od 1994-06-20 05:08:08 włącznie
    "to": 783760000000    // zakres do 1994-11-02 07:06:40 włącznie
  },
  {
    "id": "AM01_NOX",
    "level": "1h",
    "from": 808000000000,
    "to": 825955555576
  },
  {
    "id": "AM01_NOX",
    "level": "4h",        // agregacje czterogodzinne
    "from": 776090016000,
    "to": 776625062400
} ]</code></pre>
</figure>

<p>
    Struktura odpowiedzi jest bardzo podobna do żądania. Różnica jest w tym, że odpowiedź dla każdego żądania zawiera
    pole o nazwie <q>data</q> będące tablicą danych. Każdy punkt danych w tabeli posiada pola obowiązkowe o nazwach
    zaczynających się znakiem <code>$</code>.
    Są to pola <code>$s</code> oraz <code>$e</code> zawierające stempel czasowy odpowiednio początku i końca zakresu
    agregacji. Jeśli jest to punkt przedstawiający nie agregację, lecz surowy punkt pomiarowy, polem obowiązkowym jest
    pole <code>$t</code> oznaczające stempel czasowy próbki.
    Pozostałe pola traktowane są jako agregowane wartości i nie są wykorzystywane przez <em>ExploreJS</em>.
    Dopiero adapter wykresu przy wyświetlaniu punktu interpretuje we właściwy sposób te dane. Struktura przykładowego
    punktu została pokazana na listingu <a href="#code:batch-response"></a>.
</p>

<figure type="code" id="code:batch-response">
    <figcaption>Pojedynczy punkt danych w odpowiedzi serwera.</figcaption>

    <pre><code>
{
  "$e": 795301200000,    // początek agregacji
  "$s": 795297600000,    // koniec agregacji
  "a": 1698.85061111111, // wartość średnia pomiaru
  "b": 1666.49,          // wartość minimalna pomiaru
  "t": 1733.55,          // wartość maksymalna pomiaru
  "c": 360               // liczba zliczonych punktów pomiaru
}</code></pre>

</figure>

<h3>Optymalizacja zapytań</h3>
<p>
    Ze względu na dużą dynamikę wizualnej eksploracji danych pomiarowych, żądania wychodzące z mechanizmu predykcji
    generowane są dosyć częstwoi nakładają się w małych przedziałach czasowych. Co więcej, zakresy tych zapytań często
    mają niemałą część wspólną.
</p>

<p>
    Początkowa implementacja, która nie łączyła zapytań, generowała osobne żądania w takiej liczbie, że ich liczba
    namnażała się tworząc wydłużającą się kolejkę w przeglądarce <a href="#bib:browser-request-limits"></a>.

    By rozwiązać ten problem, należało na poziomie fizycznym i logicznym łączyć te zapytania.
</p>

<p>
    Łączenie fizyczne polega na wydzieleniu krótkiego odcinka czasu, w którym żądania zgłaszane do
    <em>RequestManagera</em> odkładane są do specjalnego bufora. Po upływie ustalonego czasu, zgłoszenia z bufora
    pakowane są do pojedynczego żądania <em>AJAX</em>, wysyłane do serwera, a bufor zostaje wyczyszczony. Zostało to
    zilustrowane na obrazku <a href="#picture:physical-merging"></a>.

</p>

<figure type="picture" id="picture:physical-merging">
    <figcaption>Buforowanie zapytań do <em>RequestManagera</em>. Po upływie ustalonego czasu zbuforowane zapytania
        łączone są w
        paczkę i wysyłane przez AJAX.
    </figcaption>
    <img src="cache/physical-merging.png"/>
</figure>

<p>
    Łączenie fizyczne pozwoliło na zmniejszenie liczby jednoczesnych żądań do serwera, natomiast nie rozwiązało to
    problemu, że w jednej paczce znajdowały się zapytania, których zakresy mają część wspólną, co powodowało pobieranie
    nadmiernej ilości danych, co jest sprzeczne z celem <em>ExploreJS</em>. Usunięciem tej redundancji zajmuje się
    specjalny moduł <em>MergingBatch</em> wewnątrz <em>RequestManagera</em>, który zajmuje się logicznym łączeniem żądań
    do serwera.
</p>

<p>
    Moduł scalający <em>MergingBatch</em> w zawansowany sposób łączy żądania w buforze zapytań.
    Zamiast dodawać zapytanie do listy żądań, znajduje wpierw istniejące żądania dla tej samej serii i poziomu
    agregacji i próbuje scalić te żądania z nowym żądaniem.
    W wyniku tego zamiast tworzenia kolejnego żądania, może się zmienić zakres innego, a nawet zmniejszyć liczba żądań.
    Zostało to zademonstrowane na rysunku <a href="#picture:logical-merging"></a>.
</p>

<figure type="picture" id="picture:logical-merging">
    <figcaption>Wizualizacja scalania żądań. Żądania dotyczące tej samej serii i poziomu agregacji oznaczono jednym
        kolorem.
    </figcaption>
    <img src="cache/logical-merging.png" height="300"/>
</figure>

<p>
    W tym przypadku w buforze istniały zapytania, z czego jedno dotyczyło serii danych <em>Y</em>, pozostałe <em>X</em>.
    Podczas dodawania nowego żądania o dane serii <em>X</em>, dla agregacji godzinnej, okazało się, że w buforze
    znajdują się inne żądania agregacji godzinnych tej serii. Po scaleniu tych żądań z dodawanym żądaniem, okazuje się,
    że wszystkie trzy żądania mają część wspólną, zatem zostały zastąpione jednym żądaniem.
</p>

<p>
    Moduł <em>MergingBatch</em> rozwiązuje jeszcze jeden problem.

    O ile powyższe łączenie scala żądania z tymi znajdującymi się w buforze, to nie są brane pod uwagę trwające żądania,
    które zostały wysłane do serwera.

    Może to spowodować podwójne ładowanie danych z tego powodu, że pierwsze żądanie opuściło już bufor, ale dane jeszcze
    nie zostały umieszczone w pamięci cache.

    W związku z tym <em>MergingBatch</em> tworzy dodatkowy bufor na trwające żądania.

    Podczas dodawania nowego żądania, zanim dojdzie do scalania z buforem oczekujących żądań, dochodzi do operacji
    odejmowania zakresów z bufora trwających żądań od nowego żądania.
</p>
<p>
    Całą zasadę działania <em>MergingBatch</em> na żądaniach dotyczących tej samej serii i poziomu agregacji można
    wyrazić odpowiednimi operacjami na przedziałach:
</p>

<pre class="text-center">Q<sub>2</sub> = Q<sub>1</sub> + ({A} - P)</pre>

<p style="text-indent: 0">
    gdzie <em>A</em> oznacza nowe zgłoszenie, <em>P</em> - bufor trwających zgłoszeń, <em>Q<sub>1</sub></em> - bufor
    oczekujących zgłoszeń,
    <em>Q<sub>2</sub></em> - bufor oczekujących zgłoszeń po dodaniu noweg zgłoszenia.
</p>

<p>
    Dzięki zastosowaniu <em>MergingBatch</em> nie istnieje możliwość, że serwer będzie pytany o nakładające się zakresy
    w krótkim czasie, co maksymalnie optymalizuje komunikację <em>ExploreJS</em> z serwrem.
</p>

<p note="pengingQueue i zwykła queue - opisać merging batch"></p>

<!--


<p>
implementacja: Debounce do gromadzenia zapytań do serwera, opisać merging batch
</p>

<h3>
    Interfejs HTTP JSON
</h3>
<p>
Do komunikacji HTTP z serwerem został wybrany format JSON.
Przy definiowaniu standardu należy zwrócić, uwagę, że w aplikacji użytkownika możliwe jest jednoczesne występowanie
wielu instancji komponentów wizualizacji danych. Mowa tutaj o przeglądaniu wielu serii na jednym wykresie, czy o
widokach typu panel kontrolny <span trans="ang">Dashboard</span>.
W takiej sytuacji wiele żądań jest wysyłanych jednocześnie.
</p>
<p>
    Aby minimalizować liczbę jednoczesnych zapytań, wszystkie żądania do serwera pochodzące z tej samej aplikacji pakuje
    się w jedną paczkę.
    W związku z tym interfejs serwera zdefiniowany jest tak, by zwracał w jednej odpowiedzi dane z różnych serii,
    na różnym poziomie abstrakcji, z różnego okresu czasu.
    Na listingu <a href="#code:request-format"></a> pokazano przykładowe zapytanie HTTP JSON do serwera.
    Jest to lista fragmentów danych opisanych identyfikatorem serii, poziomem abstrakcji (agregacją) oraz okresem czasu.
    Odpowiedź serwera pokazana na listingu <a href="#code:response-format"></a> zawiera listę punktów serii danych
    określonych w parametrach zapytania.
</p>
<p>
    W proponowanym formacie zapytania i odpowiedzi użytko nazwanych atrybutów dotyczących skali danych.
    Serwer danych udostępnia dane w skali dyskretnej, na przykład w agregacjach minutowych, godzinnych, dobowych,
    czy 30-dniowych.
    Jednak, z punktu widzenia eksploracji w wizualnej analizie, nie jest istotne, aby skale były ułożone
    zwyczajowo (doba, miesiąc, tydzień).
    Równie dobrze serwer może używać agregacji równych, czyli takich, gdzie kolejne agregacje są k-krotnością
    poprzedniej, na przykład: 1s, 4s, 16s, 64s, (...). W tej sytuacji na dwunastym poziomie otrzymuje się agregację
    dwuletnią. Podobne podejście stosuje się w rozłożeniu poziomów dyskretnej skali w systemach mapowych
    <a href="#bib:sample2010tile" chapter="2.2 Global Logical Tile Scheme"></a>.
</p>
<p>
    TODO która skala jest mała ktora duża
    Aby nie uzależniać kodu klienta od struktury danych serwera, serwer udostępnia dodatkową informację, tzw.
    <i>manifest</i>. Aplikacja kliencka podczas inicjalizacji pobiera manifest aby wiedzieć, z jakich skal może
    skorzystać. Na listingu <a href="#code:manifest-format"></a> przedstawiono przykładowy manifest serwera. W tym
    przypadku dane surowe są zbierane co około 10 sekund, natomaist najmniejsza skala agreguje dane w okresie 120 dni.
</p>

<figure type="code" id="code:request-format">
    <figcaption>Format zapytania o dane</figcaption>
    <code class="javascript">
        { series: [
        { id: 'serie001', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
        { id: 'serie002', 'level': 'raw', from: '2016-01-27 06:00', to: '2016-01-27 06:04' },
        { id: 'serie001', 'level': '1h',  from: '2016-01-01 12:00', to: '2016-02-23 12:00' },
        { id: 'serie003', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
        { id: 'serie003', 'level': '1d',  from: '2016-01-23 00:00', to: '2016-01-26 00:00' }
        ]}
    </code>
</figure>


<figure type="code" id="code:response-format">
    <figcaption>Format odpowiedzi serwera</figcaption>
    <code class="javascript">
        { series: [
        { id: 'serie001', 'level': '1m',
        from: '2016-01-23 13:05' to: '2016-01-23 17:57',
        data: [
        { @: '2016-01-23 13:05', a: 312.3, t: 404.1, b: 300.9 },
        { @: '2016-01-23 13:06', a: 312.7, t: 377.0, b: 300.1 },
        { @: '2016-01-23 13:07', a: 301.5, t: 304.2, b: 224.8 },
        ...
        { @: '2016-01-23 17:56', a: 813.3, t: 888.0, b: 813.1 },
        { @: '2016-01-23 17:57', a: 900.3, t: 903.1, b: 813.9 },
        ]
        },
        { id: 'serie002', 'level': 'raw',
        from: '2016-01-27 06:00', to: '2016-01-27 06:04',
        data: [
        { $: '2016-01-27 06:00:23', v: 33 },
        { $: '2016-01-27 06:00:27', v: 33 },
        { $: '2016-01-27 06:00:34', v: 34 },
        ...
        { $: '2016-01-27 06:04:23', v: 37 },
        { $: '2016-01-27 06:04:35', v: 37 },
        ]
        },
        ...
        ]}
    </code>
</figure>

<figure type="code" id="code:manifest-format">
    <figcaption>Format manifestu serwera</figcaption>
    <code class="javascript">
        {
        "series": [
        {
        "serieId": "s001",
        "start": 1448060400000,
        "end": 1448881190000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "30s", "step": 30000 },
        ...
        { "id": "120d", "step": 10370000000 }
        ]
        },
        {
        "serieId": "s002",
        "start": 1451602800000,
        "end": 1454324390000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "30s", "step": 30000 },
        ...
        { "id": "120d", "step": 10370000000 }
        ]
        },
        {
        "serieId": "s003",
        "start": 1448060400000,
        "end": 1448881190000,
        "levels": [
        { "id": "10s", "step": 10000 },
        { "id": "1m", "step": 60000 },
        ...
        { "id": "100d", "step": 86400000000 }
        ]
        }
        ]
        }
    </code>
</figure>



-->


<h2>algebra przedziałów i operacje przekształcające</h2>
<p note="opisać operacje sum sub, and, etc, że jego wyjściem jest instrukcja diff">
    dodatkowo wspomnieć o bisekcji, żeby operować tylko na małym fragmencie
    opisać gdzie występowała konieczność diffów różnorakich zbiorów (cache projection, dynamic projection recompile,
    levelCache.requestRange()..., mergingBatch!
</p>

<!--


wizualizacja operacji https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_15

<p helper="przeniesiono z architektury">
    Rozwiązanie <em>ExploreJS</em> można podzielić koncepcyjnie na moduły, które dodatkowo klasyfikują się na trzy
    kategorie
    ze względu na ich liczebność.

    Zwielokrotnienie modułów wynika z faktu, że zaproponowane rozwiązanie wspiera maksymalne współdzielenie zasobów przy
    wyświetlaniu wielu wykresów jednocześnie, na których może być wyświetlane wiele serii danych pomiarowych, a ta sama
    seria danych może być pokazywana na różnych wykresach.

    Można tutaj przywołać przykład aplikacji, w której użytkownik porównuje dane meteorologiczne w ten
    sposób, że wyświetla trzy wykresy, każdy z nich jest przesunięty względem siebie o jeden rok, a na każdym
    wyświetlane jest 6 tych samych serii pomiarowych.

    W tym przypadku rozwiązanie będzie współdzieliło zoptymalizowany kanał komunikacyjny, ale również pamięć cache dla
    każdej z 6 serii.
</p>-->




<h2>Przeliczanie projekcji</h2>

<p note="ten algorytm Front, Back, THIS, i tak dalej"></p>


<!--


fajny rysunek: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_89

zainspirować się błędnym, ale zrobionym diagramem: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_8

nawiązać do frameworków react i angular w kwestii obliczania diffów do efektywnego zarządzaniem UI.
        Nie możemy po prostu liczyć diffów z całego zbioru (tak jak to robi react) w celu przebudowania UI, musimy
        liczyć diff w locie.
        React źle znosi liczenie wielkich diffów (gdyby w ten sposób deklarować renderowanie big data).
        Big data - cache może być wielki (długo działająca aplikacja), więc przeliczanie diffow nie wchodzi w rachubę.

<pre>
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓        ┏━━━━━┓        ┏━━━━━┓        │
    │   1     2        3     4        5     6        │
    ├ T                                              │
    │                                                │
    ├ B                                              │
    │                                                │
    ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
    │   0                                         7  │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 1 2 3 4 5 6 │
    ├ T ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    ├ B │
    │ │
    ├ R ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    └────────────────────────────────────────────────┘
</pre>
<figure type="code" id="code:demo1">
    <pre>
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T                                              │
        │                                                │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
        │   0                                         7  │
        └────────────────────────────────────────────────┘
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        └────────────────────────────────────────────────┘
    </pre>
</figure>



<p helper="z konwersacji">
    [11:47 AM] Adam Borowski [Atlassian]: algorytmy ktore mi zajely duzo czasu to operacje UNION oraz SUBTRACT na takiej
    strukturze jak zbiór przedziałów (interval set).
    Same operacje są banalne, i są biblioteki na to, ale to co stanowi wyzwanie to obliczenie kroków transformacji
    pierwszego zbioru, aby stał się tym drugim  ( w czasie liniowym). To jest rodzaj algorytmu DIFF ale tworzony podczas
    wykonywania samej operacji UNION i SUBTRACT.
    Przykładowy test który może to ilustruje:
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('0 1 1 10'), rng('2 6 9 10 13 20'))).to.deep.equal({
    added: rng('6 9'),
    removed: [],
    resized: rng('[1 10->2]'),
    result: rng('[0 1] [1 10->2] 6 9')
    });
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('2 6 7 17 18 28'), rng('0 7 7 12 12 13'))).to.deep.equal({
    added: [],
    removed: rng('2 6'),
    resized: rng('[7->13 17]'),
    result: rng('[7->13 17] [18 28]')
    });
    [11:50 AM] Adam Borowski [Atlassian]: rysuneczek dla operacij C=A-B
    [11:50 AM] Adam Borowski [Atlassian]:
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 4 7 10 20 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ │
    │ 2 8 10 13 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 13 20 │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
    [11:52 AM] Adam Borowski [Atlassian]: w tym przypadku algorytm zwraca oprocz samego wyniku C=A-B inofrmacje:
    [1 2] pozostaje bez zmian
    [4 7] rozszerza się do [2 8]
    [10 20] zwęża się do [13 20]
    [11:53 AM] Adam Borowski [Atlassian]: sorki ze Ci spamuje ale jak juz tlumacze to te notatki sobie wkleje roboczo do
    magisterki zeby z tego podrozdzial zrobic
    [11:56 AM] Adam Borowski [Atlassian]: oczywiscie to dziala dla wszystkich case, na przykład gdy przedział z B
    rozdziela jeden przdział z A na dwa przedziały
    [11:56 AM] Adam Borowski [Atlassian]:
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 11 14 15 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━┓ │
    │ 2 7 9 11 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 2 7 9 14 15 │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
    [12:00 PM] Adam Borowski [Atlassian]: a odpowiedź algorytmu taka:
    [12:00 PM] Adam Borowski [Atlassian]:
    {
    "result": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    },
    {
    "start": 7,
    "end": 9
    },
    {
    "start": 14,
    "end": 15,
    "existing": {
    "start": 14,
    "end": 15
    }
    }
    ],
    "added": [
    {
    "start": 7,
    "end": 9
    }
    ],
    "removed": [],
    "resized": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    }
    ]
    }
</p>


-->

<h2 id="chapter:implementation-adapter">Adapter komponentu wykresu</h2>
<p note="chodzi o wykresy i ich aktualizacje oraz interfejsy <q>patch</q> (visjs) i <q>replace</q> (flot)">
    (pseudokod adaptera?)
</p>

<!--

TODO: rozważanie o sposobie powiadamiania klienta o zmianach danych
<ul>
    <li>powiadomienie, że gdzieś coś się zmieniło, wtedy użytkownik albo sam robi diffa, albo resetuje komponent
        wykresów. to może powodować bad UX, migotanie, itd
    </li>
    <li>powiadomienie o dokładnych zmianach. instrukcja co krok po kroku należy zmienić, aby przejść ze stanu obecnego
        do wyjsciowego. minimalizacja liczby kroków.
        Jaki fragment danych z wykresu usunąć ( z jakiej warstwy).
        Jaki fragment danych z wykresu poszerzyć (z jakiej warstwy).
        Jaki fragment do danych z wykresu dodać (z jakiej warstwy).
        Common pattern byłby taki, że albo każda seria to inna warstwa, albo jedna seria ma punkty ze wszystkich warstw.
    </li>
</ul>
<figure type="code">
    <code class="javascript">
        class ExampleZingAdapter extends ClientProxyAdapter{
        processChange(diff) {
        // diff.added, diff.removed, diff.resized -- > {layer:[Number], start, end}
for(var removedRange of diff.removed){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
for(var addedRange of diff.added){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
}
}
</code>
</figure>
-->


<p helper="">
    problemy implementacyjne https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_27
</p>


<h2>Wraper dla agregacji</h2>

<!--
Konieczność wrapperdisplay cache i translacja data-projection-data

implementacja: Skale zwyczajowe (użytkowe np dzień 12, tydzień 53, miesiąc, etc) nie robią problemu u mnie, bo każda
            agregacja ma parametr czas otwarcia i czas zamknięcia okresu który reprezentują. Żadną agregacja nie musi
            być wielokrotnościa poprzedniej, bo punkty agregacji są niezależne pomiędzy warstwami.
            Dopiero CacheProjection dobiera sobie agregację do zakresów czasu, ale znowu, każda agregacja ma wpisany
            czas za który odpowiada.
-->

<h2>Problemy z integracją z bibliotekami</h2>
<ul>
    <li>ZingChart
        * obfuscowany kod, debugging, errory...
        * beznadziejne API globalnych komend, nie da się niektórych rzeczy łatwo uzyskać ustawić
        * chyba wypełniad dziury między date.getTime() a date.getTime() co trwa bardzo długo... alokacja kilkadziesiat sekund - nie można przyczyny normalnie zdebugować
        * brak normalnego pan&zoom
        * jakieś dziwne przeliczenia iteracja po dziedzinie co "1" - od jednej daty do drugiej może minąć dużo czasu -
        to jednoznacznie dyskwalifikuje - dzieje się to w momencie gdy następuje zmiana zakresu wyświetlanego
    </li>
</ul>
<h2>Wykorzystane narzędzia i środowiska</h2>

<p helper="prezentacja 2">
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_39
</p>
<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

</p>

<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>


<h2>Klasa Range</h2>

<p note="opisać wszystkie metody klasy Range  i po co mogą być potrzoebne"></p>

<h2>DynamicProjection</h2>

<p helper>

    przełączanie się,
    range scoped event
    opisać kafelkowanie zakresu danych (żeby predyktor nie doładowywał małych słupków podczas smooth paningu
    Nakładanie się warstw o dynamicznej zawartosci, jak w nakładaniu obrazów. Niemożliwe prxerysowywanie od
    początku, tylko minimalne fragmenty. Wyliczanie tych fragmentów stanowi trudność.
</p>


<figure type="picture" id="picture:dynamic-projection">
    <figcaption>Diagram pokazujący zwielokrotnienie modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/serie-cache-diagram.png">
</figure>




<h2>Modele predykcji</h2>

<p note="zaimplementowane modele predykcji" helper>
    implementacja: prediction models i dynamicProjection - paddingi, <strong>tiles</strong> muszą być sensownie dopasowane,
    żeby np wykres nie byl co chwile przerysowany, bo jakis drobnostkowy model predykcji co chwile aktualizuje
    mały kawałeczek
</p>
