<!--suppress HtmlUnknownTag -->
<h1 id="chapter:implementation">Implementacja</h1>
<p helper="">
    problemy implementacyjne https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_27

    Prezentacja kluczowych algorytmów do zarządzania fragmentami serii danych w pamięci podręcznej
    Prezentacja kluczowych algorytmów do prezentacji pofragmentowanych danych na ekranie
    Prezentacja algorytmów predykcji akcji użytkownika



</p>
<h2>Serwer danych</h2>
<p>
    Proponowane rozwiązanie, ExploreJS jest niezależne od wykorzystywanego oprogramowania po stronie serwera.
    W związku z tym, dla każdego wskazanego serwera konieczne jest jego zintegrowanie poprzez implementację określonego
    interfejsu zapytania i odpowiedzi.
</p>
<h3>
    Interfejs HTTP JSON
</h3>
<p>
    <!--TODO dlaczego wybrałem JSON-->
    Do komunikacji HTTP z serwerem został wybrany format JSON.
    <!-- TODO dlaczego jednoczesne zapytania są złe-->
    Przy definiowaniu standardu należy zwrócić, uwagę, że w aplikacji użytkownika możliwe jest jednoczesne występowanie
    wielu instancji komponentów wizualizacji danych. Mowa tutaj o przeglądaniu wielu serii na jednym wykresie, czy o
    widokach typu panel kontrolny <span trans="ang">Dashboard</span>.
    W takiej sytuacji wiele żądań jest wysyłanych jednocześnie.
</p>
<p>
    Aby minimalizować liczbę jednoczesnych zapytań, wszystkie żądania do serwera pochodzące z tej samej aplikacji pakuje
    się w jedną paczkę.
    W związku z tym interfejs serwera zdefiniowany jest tak, by zwracał w jednej odpowiedzi dane z różnych serii,
    na różnym poziomie abstrakcji, z różnego okresu czasu.
    Na listingu <a href="#code:request-format"></a> pokazano przykładowe zapytanie HTTP JSON do serwera.
    Jest to lista fragmentów danych opisanych identyfikatorem serii, poziomem abstrakcji (agregacją) oraz okresem czasu.
    Odpowiedź serwera pokazana na listingu <a href="#code:response-format"></a> zawiera listę punktów serii danych
    określonych w parametrach zapytania.
</p>
<p>
    W proponowanym formacie zapytania i odpowiedzi użytko nazwanych atrybutów dotyczących skali danych.
    Serwer danych udostępnia dane w skali dyskretnej, na przykład w agregacjach minutowych, godzinnych, dobowych,
    czy 30-dniowych.
    Jednak, z punktu widzenia eksploracji w wizualnej analizie, nie jest istotne, aby skale były ułożone
    zwyczajowo (doba, miesiąc, tydzień).
    Równie dobrze serwer może używać agregacji równych, czyli takich, gdzie kolejne agregacje są k-krotnością
    poprzedniej, na przykład: 1s, 4s, 16s, 64s, (...). W tej sytuacji na dwunastym poziomie otrzymuje się agregację
    dwuletnią. Podobne podejście stosuje się w rozłożeniu poziomów dyskretnej skali w systemach mapowych
    <a href="#bib:sample2010tile" chapter="2.2 Global Logical Tile Scheme"></a>.
</p>
<p>
    <!--TODO która skala jest mała ktora duża-->
    Aby nie uzależniać kodu klienta od struktury danych serwera, serwer udostępnia dodatkową informację, tzw.
    <i>manifest</i>. Aplikacja kliencka podczas inicjalizacji pobiera manifest aby wiedzieć, z jakich skal może
    skorzystać. Na listingu <a href="#code:manifest-format"></a> przedstawiono przykładowy manifest serwera. W tym
    przypadku dane surowe są zbierane co około 10 sekund, natomaist najmniejsza skala agreguje dane w okresie 120 dni.
</p>

<figure type="code" id="code:request-format">
    <figcaption>Format zapytania o dane</figcaption>
    <code class="javascript">
        { series: [
            { id: 'serie001', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
            { id: 'serie002', 'level': 'raw', from: '2016-01-27 06:00', to: '2016-01-27 06:04' },
            { id: 'serie001', 'level': '1h',  from: '2016-01-01 12:00', to: '2016-02-23 12:00' },
            { id: 'serie003', 'level': '1m',  from: '2016-01-23 13:05', to: '2016-01-23 17:57' },
            { id: 'serie003', 'level': '1d',  from: '2016-01-23 00:00', to: '2016-01-26 00:00' }
        ]}
    </code>
</figure>


<figure type="code" id="code:response-format">
    <figcaption>Format odpowiedzi serwera</figcaption>
    <code class="javascript">
        { series: [
            { id: 'serie001', 'level': '1m',
                from: '2016-01-23 13:05' to: '2016-01-23 17:57',
                data: [
                    { @: '2016-01-23 13:05', a: 312.3, t: 404.1, b: 300.9 },
                    { @: '2016-01-23 13:06', a: 312.7, t: 377.0, b: 300.1 },
                    { @: '2016-01-23 13:07', a: 301.5, t: 304.2, b: 224.8 },
                    ...
                    { @: '2016-01-23 17:56', a: 813.3, t: 888.0, b: 813.1 },
                    { @: '2016-01-23 17:57', a: 900.3, t: 903.1, b: 813.9 },
                ]
            },
            { id: 'serie002', 'level': 'raw',
                from: '2016-01-27 06:00', to: '2016-01-27 06:04',
                data: [
                    { $: '2016-01-27 06:00:23', v: 33 },
                    { $: '2016-01-27 06:00:27', v: 33 },
                    { $: '2016-01-27 06:00:34', v: 34 },
                    ...
                    { $: '2016-01-27 06:04:23', v: 37 },
                    { $: '2016-01-27 06:04:35', v: 37 },
                ]
            },
            ...
        ]}
    </code>
</figure>

<figure type="code" id="code:manifest-format">
    <figcaption>Format manifestu serwera</figcaption>
    <code class="javascript">
 {
    "series": [
        {
            "serieId": "s001",
            "start": 1448060400000,
            "end": 1448881190000,
            "levels": [
                { "id": "10s", "step": 10000 },
                { "id": "30s", "step": 30000 },
                ...
                { "id": "120d", "step": 10370000000 }
            ]
        },
        {
            "serieId": "s002",
            "start": 1451602800000,
            "end": 1454324390000,
            "levels": [
                { "id": "10s", "step": 10000 },
                { "id": "30s", "step": 30000 },
                ...
                { "id": "120d", "step": 10370000000 }
            ]
        },
        {
            "serieId": "s003",
            "start": 1448060400000,
            "end": 1448881190000,
            "levels": [
                { "id": "10s", "step": 10000 },
                { "id": "1m", "step": 60000 },
                ...
                { "id": "100d", "step": 86400000000 }
            ]
        }
    ]
}
    </code>
</figure>

<h2>Pośrednik aplikacji klienta</h2>
TODO: rozważanie o sposobie powiadamiania klienta o zmianach danych
<ul>
    <li>powiadomienie, że gdzieś coś się zmieniło, wtedy użytkownik albo sam robi diffa, albo resetuje komponent
        wykresów. to może powodować bad UX, migotanie, itd
    </li>
    <li>powiadomienie o dokładnych zmianach. instrukcja co krok po kroku należy zmienić, aby przejść ze stanu obecnego
        do wyjsciowego. minimalizacja liczby kroków.
        Jaki fragment danych z wykresu usunąć ( z jakiej warstwy).
        Jaki fragment danych z wykresu poszerzyć (z jakiej warstwy).
        Jaki fragment do danych z wykresu dodać (z jakiej warstwy).
        Common pattern byłby taki, że albo każda seria to inna warstwa, albo jedna seria ma punkty ze wszystkich warstw.
    </li>
</ul>
<figure type="code">
    <code class="javascript">
        class ExampleZingAdapter extends ClientProxyAdapter{
            processChange(diff) {
                // diff.added, diff.removed, diff.resized --> {layer:[Number], start, end}
                for(var removedRange of diff.removed){
                    this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
                }
                for(var addedRange of diff.added){
                    this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
                }
            }
        }
    </code>
</figure>
<h3>Mechanizm cache</h3>
TODO struktura danych, operacje na zbiorach przedziałów

<pre>
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓        ┏━━━━━┓        ┏━━━━━┓        │
    │   1     2        3     4        5     6        │
    ├ T                                              │
    │                                                │
    ├ B                                              │
    │                                                │
    ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
    │   0                                         7  │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 1 2 3 4 5 6 │
    ├ T ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    ├ B │
    │ │
    ├ R ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    └────────────────────────────────────────────────┘
</pre>
</p>
<figure type="code" id="code:demo1">
    <pre>
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T                                              │
        │                                                │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
        │   0                                         7  │
        └────────────────────────────────────────────────┘
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        └────────────────────────────────────────────────┘
    </pre>
</figure>


<p helper="z konwersacji">
    [11:47 AM] Adam Borowski [Atlassian]: algorytmy ktore mi zajely duzo czasu to operacje UNION oraz SUBTRACT na takiej
    strukturze jak zbiór przedziałów (interval set).
    Same operacje są banalne, i są biblioteki na to, ale to co stanowi wyzwanie to obliczenie kroków transformacji
    pierwszego zbioru, aby stał się tym drugim  ( w czasie liniowym). To jest rodzaj algorytmu DIFF ale tworzony podczas
    wykonywania samej operacji UNION i SUBTRACT.
    Przykładowy test który może to ilustruje:
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('0 1 1 10'), rng('2 6 9 10 13 20'))).to.deep.equal({
    added: rng('6 9'),
    removed: [],
    resized: rng('[1 10->2]'),
    result: rng('[0 1] [1 10->2] 6 9')
    });
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('2 6 7 17 18 28'), rng('0 7 7 12 12 13'))).to.deep.equal({
    added: [],
    removed: rng('2 6'),
    resized: rng('[7->13 17]'),
    result: rng('[7->13 17] [18 28]')
    });
    [11:50 AM] Adam Borowski [Atlassian]: rysuneczek dla operacij C=A-B
    [11:50 AM] Adam Borowski [Atlassian]:
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 4 7 10 20 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ │
    │ 2 8 10 13 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 13 20 │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
    [11:52 AM] Adam Borowski [Atlassian]: w tym przypadku algorytm zwraca oprocz samego wyniku C=A-B inofrmacje:
    [1 2] pozostaje bez zmian
    [4 7] rozszerza się do [2 8]
    [10 20] zwęża się do [13 20]
    [11:53 AM] Adam Borowski [Atlassian]: sorki ze Ci spamuje ale jak juz tlumacze to te notatki sobie wkleje roboczo do
    magisterki zeby z tego podrozdzial zrobic
    [11:56 AM] Adam Borowski [Atlassian]: oczywiscie to dziala dla wszystkich case, na przykład gdy przedział z B
    rozdziela jeden przdział z A na dwa przedziały
    [11:56 AM] Adam Borowski [Atlassian]:
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 11 14 15 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━┓ │
    │ 2 7 9 11 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 2 7 9 14 15 │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
    [12:00 PM] Adam Borowski [Atlassian]: a odpowiedź algorytmu taka:
    [12:00 PM] Adam Borowski [Atlassian]:
    {
    "result": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    },
    {
    "start": 7,
    "end": 9
    },
    {
    "start": 14,
    "end": 15,
    "existing": {
    "start": 14,
    "end": 15
    }
    }
    ],
    "added": [
    {
    "start": 7,
    "end": 9
    }
    ],
    "removed": [],
    "resized": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    }
    ]
    }
</p>

<h2>Problemy implementacyne
    <small>(notatka)</small>
</h2>
<p>TODO</p>
<ul>
    <li>opisać gdzie występowała konieczność diffów różnorakich zbiorów (cache projection, dynamic projection recompile,
        levelCache.requestRange()...
    </li>
    <li>nawiązać do frameworków react i angular w kwestii obliczania diffów do efektywnego zarządzaniem UI.
        Nie możemy po prostu liczyć diffów z całego zbioru (tak jak to robi react) w celu przebudowania UI, musimy
        liczyć diff w locie.
        React źle znosi liczenie wielkich diffów (gdyby w ten sposób deklarować renderowanie big data).
        Big data - cache może być wielki (długo działająca aplikacja), więc przeliczanie diffow nie wchodzi w rachubę.
    </li>
    <li>
        Optymalizacja mergowanie pending level request, queued level request, prioritety
    </li>
    <li>
        Konieczność wrapperdisplay cache i translacja data-projection-data
    </li>

</ul>
<h3>Problemy z integracją z bibliotekami</h3>
<ul>
    <li>ZingChart
        * obfuscowany kod, debugging, errory...
        * beznadziejne API globalnych komend, nie da się niektórych rzeczy łatwo uzyskać ustawić
        * chyba wypełniad dziury między date.getTime() a date.getTime() co trwa bardzo długo... alokacja kilkadziesiat sekund - nie można przyczyny normalnie zdebugować
        * brak normalnego pan&zoom
        * jakieś dziwne przeliczenia iteracja po dziedzinie co "1" - od jednej daty do drugiej może minąć dużo czasu -
        to jednoznacznie dyskwalifikuje - dzieje się to w momencie gdy następuje zmiana zakresu wyświetlanego
    </li>
</ul>
<h3>Wykorzystane narzędzia i środowiska</h3>
<p helper="prezentacja 2">
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_39
</p>