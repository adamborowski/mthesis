<h1 id="chapter:implementation">Implementacja</h1>

<p>
    Niniejszy rozdział stanowi uzupełnienie do rozdziału <a href="#chapter:solution"></a>, wyjaśniające zasadę działania
    ważniejszych elementów proponowanego w tej pracy rozwiązania problemu płynnej i nieograniczonej wizualnej
    eksploracji danych pomiarowych.
</p>
<p>
    Zastosowanie biblioteki <em>ExploreJS</em> w praktyce pozwala na:
</p>
<ul>
    <li>wyświetlanie wielu komponentów wykresów jednocześnie,</li>
    <li>wyświetlanie tej samej serii danych w różnych wykresach, w dowolnych zakresach,</li>
    <li>wyświetlanie wielu serii na jednym wykresie.</li>
</ul>

<p>
    By wydajnie wspierać powyższe funkcje, <em>ExploreJS</em> maksymalizuje współdzielenie zasobów w ramach całej
    aplikacji w przeglądarce:
</p>
<ul>
    <li>wszystkie zapytania o dane do serwera są zarządzane przez jeden moduł <em>ReqestManager</em>,</li>
    <li>moduł <em>CacheManager</em> powiela moduł <em>SerieCache</em> (odpowiedzialny za pamięć podręczną serii i
        projekcje warstw) dla każdej serii danych,
    </li>
    <li>moduł <em>DataSource</em> tworzony jest dla każdego komponentu wykresu osobno.</li>
</ul>

<p>
    Diagram <a href="#picture:architecture"></a> pokazuje przykładowe ustawienie modułów dla aplikacji z trzema
    wykresami, gdzie pierwszy oraz trzeci wyświetlają dane z tej samej serii danych pomiarowych.
</p>

<p>
    Każdy komponent wykresowy podłączony jest do swojego <em>DataSource</em> poprzez adapter specyficzny dla danego typu
    komponentu (oznaczony symbolem interfejsu).
    Informuje o interakcji użytkownika oraz przyjmuje nowe dane do aktualizacji.
</p>

<p>
    Każda instancja <em>DataSource</em> posiada inny zestaw modeli predykcji, w związku z czym silnik predykcji, zawarty
    w każdej instancji <em>DataSource</em> może reagować na interakcję użytkownika inaczej.
    Każda z siedmiu instancji modelu predykcji niezależnie odwołuje się do pamięci podręcznej adekwatnej serii danych.
</p>

<p>
    Wewnątrz instancji <em>DataSource</em> umieszczone są instancje <em>DynamicProjection</em>, które szczegółowo
    opisane są w dalszej części tego rozdziału.
</p>

<p>
    Moduł <em>CacheManager</em> zarządza instancjami <em>SerieCache</em>, których zadaniem jest obsługa wielowarstwowej
    pamięci podręcznej oraz jej projekcji, opisanej w rozdziale <a href="#chapter:multilayer-cache"></a>.
</p>

<p>
    Moduł <em>RequestManager</em> obsługuje żądania z pamięci <em>cache</em> wszystkich serii danych, grupuje je w
    większe paczki, wysyła je do serwera danych, a odpowiedź rozpakowuje i rozsyła do adektwatnych instancji <em>SerieCache</em>.
</p>

<p>
    Serwer REST implementuje uzgodniony format JSON zapytania i odpowiedzi, odpytuje serwer danych lub bezpośrednio bazę danych.
</p>


<figure type="picture" id="picture:architecture">
    <figcaption>Diagram pokazujący liczebność instancji modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/client-architecture.png">
</figure>



<h2>Komunikacja z serwerem REST</h2>

<p>
    Biblioteka <em>ExploreJS</em> jest niezależna od wykorzystywanego oprogramowania po stronie serwera.

    Należy jednak pamiętać, że serwer danych musi udostępniać dane zagregowane w miarę równomiernie rozłożonymi
    poziomami agregacji, jak jest to opisane w rozdziale <a href="#chapter:data-reduction"></a>.

</p>

<p>
    Serwis REST udostępniać musi dwa zasoby.

    Ich ścieżka jest konfigurowalna podczas inicjalizacji <em>ExploreJS</em>.

    Pierwszym zasobem jest <code>GET /manifest</code>, drugim <code>POST /batch</code>.

    Tutaj nasuwa się pytanie, dlaczego serwis odczytujący dane obsługuje metodę <code>POST</code>, służącą zwyczajowo do
    dodawania nowych zasobów do serwera.

    Zapytanie <code>batch</code> zawiera dane w swoim ciele <trans lang="ang">request body</trans>.

    Mimo, że właściwa do tego zastosowania metoda <code>GET</code> oficjalnie wspiera <trans> request body</trans>, to
    implementacje wielu systemów się tego nie spodziewają.

    By uniknąć problemów z wycinaniem tej części zapytania przez systemy <em>firewall</em> lub mechanizm filtrów w <em>JAVA
    Enterprise</em>, stosuje się wyjątkowo metodę POST.
</p>

<h3>Manifest danych pomiarowych</h3>
<p>
    Podczas inicjalizacji <em>ExploreJS</em> w aplikacji w przeglądarce, do serwera zostaje wysłane zapytanie
    <code>GET /manifest</code>, które zawiera ważne z punktu widzenia biblioteki informacje o udostępnianych danych
    (pokazane na listingu <a href="#code:manifest"></a> ).
    Dla każdej serii danych pomiarowych zwracany jest:
</p>
<ul>
    <li>identyfikator serii,</li>
    <li>początek i koniec zakresu wszystkich dostępnych danych,</li>
    <li>informację o udostępnianych poziomach agregacji, gdzie dla każdego poziomu zdefiniowane są:
        <ul>
            <li>identyfikator agregacji,</li>
            <li>długość okresu agregowania.</li>
        </ul>
    </li>
</ul>

<figure type="code" id="code:manifest">
    <figcaption>Przykładowa odpowiedź manifestu danych</figcaption>
    <pre><code class="json">
{ "series":[
      {
         "start": 1317427200000, // 2011-10-01
         "end": 1496880000000,   // 2017-06-08
         "serieId": "AM01_NOX",  // stężenie tlenku azotu na stacji pomiarowej numer 1
         "levels":[
            { "id": "30s", "step": 30000 },
            { "id": "1m", "step": 60000 },
            [...]
            { "id": "90d", "step": 7776000000 },
            { "id": "1y", "step": 31536000000 }
         ]
      },
      [...]
] }</code></pre>
</figure>

<p>
    Dzięki manifestowi wiadomo, jakie są dostępne poziomy agregacji.
    Jest to niezbędne do wyznaczania odpowiedniego poziomu agregacji do wyświetlenia.
    Manifest również jest używany przez modele predykcji.
</p>

<p>
    Po pobraniu manifestu zostają utworzone instancje <em>SerieCache</em> odpowiedzialne za obsługę pamięci
    <em>cache</em> oraz jej projekcji.
</p>

<p>
    Ważne jest również to, że w celu uproszczenia rozwiązania, dane surowe są traktowane przez <em>ExploreJS</em>
    również jako agregacje danych. Z punktu widzenia działania mechanizmów wewnątrz <em>ExploreJS</em> nie ma
    rozróżnienia między danymi surowymi a agregacjami tych danych. Przyjmuje się, że dane surowe oznacza się
    identyfikatorem <q>raw</q> o długości agregowanego zakresu odpowiadającej średniej częstości zbierania tych danych.
    Dla danych monitoringu jakości powietrza będzie to okres <em>10s</em>, dla danych medycznych przykładowo
    <em>50ms</em>. Rozróżnienie danych surowych od agregacji jest istotne dopiero przy wyświetlaniu danych na wykresie,
    co zostało omówione w rozdziale <a href="#chapter:implementation-adapter"></a>.
</p>

<h3>Grupowe zapytania o dane</h3>

<p>
    Drugim typem zapytań są zapytania o same dane pomiarowe.

    Zapytanie jest tak naprawdę paczką zapytań, zgrupowanych przez moduł <em>RequestManager</em>.

    W ciele zapytania <code>POST /batch</code> znajduje się zbiór żądań o dane z różnych serii, różnych poziomów
    agregacji oraz różnych zakresów danych, jak pokazano na listingu <a href="#code:batch"></a>.
</p>

<figure type="code" id="code:batch">
    <figcaption>Przykładowe ciało grupowego żądania o dane</figcaption>
    <pre><code class="json">
[ {
    "id": "AM01_NOX",     // stężenie tlenku azotu na stacji pomiarowej numer 1
    "level": "1h",        // agregacje godzinne
    "from": 772088888908, // zakres od 1994-06-20 05:08:08 włącznie
    "to": 783760000000    // zakres do 1994-11-02 07:06:40 włącznie
  },
  {
    "id": "AM01_NOX",
    "level": "1h",
    "from": 808000000000,
    "to": 825955555576
  },
  {
    "id": "AM01_NOX",
    "level": "4h",        // agregacje czterogodzinne
    "from": 776090016000,
    "to": 776625062400
} ]</code></pre>
</figure>

<p>
    Struktura odpowiedzi jest bardzo podobna do żądania. Różnica jest w tym, że odpowiedź dla każdego żądania zawiera
    pole o nazwie <q>data</q> będące tablicą danych. Każdy punkt danych w tabeli posiada pola obowiązkowe o nazwach
    zaczynających się znakiem <code>$</code>.
    Są to pola <code>$s</code> oraz <code>$e</code> zawierające stempel czasowy odpowiednio początku i końca zakresu
    agregacji. Jeśli jest to punkt przedstawiający nie agregację, lecz surowy punkt pomiarowy, polem obowiązkowym jest
    pole <code>$t</code> oznaczające stempel czasowy próbki.
    Pozostałe pola traktowane są jako agregowane wartości i nie są wykorzystywane przez <em>ExploreJS</em>.
    Dopiero adapter wykresu przy wyświetlaniu punktu interpretuje we właściwy sposób te dane. Struktura przykładowego
    punktu została pokazana na listingu <a href="#code:batch-response"></a>.
</p>

<figure type="code" id="code:batch-response">
    <figcaption>Pojedynczy punkt danych w odpowiedzi serwera.</figcaption>

    <pre><code>
{
  "$e": 795301200000,    // początek agregacji
  "$s": 795297600000,    // koniec agregacji
  "a": 1698.85061111111, // wartość średnia pomiaru
  "b": 1666.49,          // wartość minimalna pomiaru
  "t": 1733.55,          // wartość maksymalna pomiaru
  "c": 360               // liczba zliczonych punktów pomiaru
}</code></pre>

</figure>

<h3>Optymalizacja zapytań</h3>
<p>
    Ze względu na dużą dynamikę wizualnej eksploracji danych pomiarowych, żądania wychodzące z mechanizmu predykcji
    generowane są dosyć częstwoi nakładają się w małych przedziałach czasowych. Co więcej, zakresy tych zapytań często
    mają niemałą część wspólną.
</p>

<p>
    Początkowa implementacja, która nie łączyła zapytań, generowała osobne żądania w takiej liczbie, że ich liczba
    namnażała się tworząc wydłużającą się kolejkę w przeglądarce <a href="#bib:browser-request-limits"></a>.

    By rozwiązać ten problem, należało na poziomie fizycznym i logicznym łączyć te zapytania.
</p>

<p>
    Łączenie fizyczne polega na wydzieleniu krótkiego odcinka czasu, w którym żądania zgłaszane do
    <em>RequestManagera</em> odkładane są do specjalnego bufora. Po upływie ustalonego czasu, zgłoszenia z bufora
    pakowane są do pojedynczego żądania <em>AJAX</em>, wysyłane do serwera, a bufor zostaje wyczyszczony. Zostało to
    zilustrowane na obrazku <a href="#picture:physical-merging"></a>.

</p>

<figure type="picture" id="picture:physical-merging">
    <figcaption>Buforowanie zapytań do <em>RequestManagera</em>. Po upływie ustalonego czasu zbuforowane zapytania
        łączone są w
        paczkę i wysyłane przez AJAX.
    </figcaption>
    <img src="cache/physical-merging.png"/>
</figure>

<p>
    Łączenie fizyczne pozwoliło na zmniejszenie liczby jednoczesnych żądań do serwera, natomiast nie rozwiązało to
    problemu, że w jednej paczce znajdowały się zapytania, których zakresy mają część wspólną, co powodowało pobieranie
    nadmiernej ilości danych, co jest sprzeczne z celem <em>ExploreJS</em>. Usunięciem tej redundancji zajmuje się
    specjalny moduł <em>MergingBatch</em> wewnątrz <em>RequestManagera</em>, który zajmuje się logicznym łączeniem żądań
    do serwera.
</p>

<p>
    Moduł scalający <em>MergingBatch</em> w zawansowany sposób łączy żądania w buforze zapytań.
    Zamiast dodawać zapytanie do listy żądań, znajduje wpierw istniejące żądania dla tej samej serii i poziomu
    agregacji i próbuje scalić te żądania z nowym żądaniem.
    W wyniku tego zamiast tworzenia kolejnego żądania, może się zmienić zakres innego, a nawet zmniejszyć liczba żądań.
    Zostało to zademonstrowane na rysunku <a href="#picture:logical-merging"></a>.
</p>

<figure type="picture" id="picture:logical-merging">
    <figcaption>Wizualizacja scalania żądań. Żądania dotyczące tej samej serii i poziomu agregacji oznaczono jednym
        kolorem.
    </figcaption>
    <img src="cache/logical-merging.png" height="300"/>
</figure>

<p>
    W tym przypadku w buforze istniały zapytania, z czego jedno dotyczyło serii danych <em>Y</em>, pozostałe <em>X</em>.
    Podczas dodawania nowego żądania o dane serii <em>X</em>, dla agregacji godzinnej, okazało się, że w buforze
    znajdują się inne żądania agregacji godzinnych tej serii. Po scaleniu tych żądań z dodawanym żądaniem, okazuje się,
    że wszystkie trzy żądania mają część wspólną, zatem zostały zastąpione jednym żądaniem.
</p>

<p>
    Moduł <em>MergingBatch</em> rozwiązuje jeszcze jeden problem.

    O ile powyższe łączenie scala żądania z tymi znajdującymi się w buforze, to nie są brane pod uwagę trwające żądania,
    które zostały wysłane do serwera.

    Może to spowodować podwójne ładowanie danych z tego powodu, że pierwsze żądanie opuściło już bufor, ale dane jeszcze
    nie zostały umieszczone w pamięci cache.

    W związku z tym <em>MergingBatch</em> tworzy dodatkowy bufor na trwające żądania.

    Podczas dodawania nowego żądania, zanim dojdzie do scalania z buforem oczekujących żądań, dochodzi do operacji
    odejmowania zakresów z bufora trwających żądań od nowego żądania.
</p>
<p>
    Całą zasadę działania <em>MergingBatch</em> na żądaniach dotyczących tej samej serii i poziomu agregacji można
    wyrazić odpowiednimi operacjami na przedziałach:
</p>

<pre class="text-center">Q<sub>2</sub> = Q<sub>1</sub> + ({A} - P)</pre>

<p style="text-indent: 0">
    gdzie <em>A</em> oznacza nowe zgłoszenie, <em>P</em> - bufor trwających zgłoszeń, <em>Q<sub>1</sub></em> - bufor
    oczekujących zgłoszeń,
    <em>Q<sub>2</sub></em> - bufor oczekujących zgłoszeń po dodaniu noweg zgłoszenia.
</p>

<p>
    Dzięki zastosowaniu <em>MergingBatch</em> nie istnieje możliwość, że serwer będzie pytany o nakładające się zakresy
    w krótkim czasie, co maksymalnie optymalizuje komunikację <em>ExploreJS</em> z serwrem.
</p>


<h2>Algebra przedziałów i operacje przekształcające</h2>

<p>
    Algorytmy i struktury danych używane w implementacji rozwiązania w głównej mierze opierają się na algebrze
    przedziałów. Wykorzystuje się ją w takich miejscach, jak:
</p>

<ul>
    <li>scalanie żądań przez <em>MergingBatch</em></li>
    <li>operacje na pamięci podręcznej</li>
    <li>obliczanie projekcji <em>cache</em></li>
    <li>implementacja czasowego modelu zdarzeniowego (opisane później)</li>
    <li>modele predykcji</li>
    <li>dobór zakresu danych w <em>DataSource</em></li><!--(DynamicProjection)-->
</ul>

<p>
    W celu usystematyzowania implementacji wprowadzono strukturę danych <em>Range</em>.

    Jest przedział o dowolnym domknięciu przechowujący wartość &mdash;
    np. <code><2016-05-04 11:00, 2016-05-04 14:00)</code> o wartości <code>{min:2, max:4,avg:2.23}</code>

    <em>Range</em> udostępnia metody do wyrażania zależności między innymi <em>Range</em>, co zostało przedstawione w
    tabeli <a href="#table:range"></a>. Ważną częścią implementacyjną jest to, że brane są pod uwagę typy brzegów, na
    przykład <q>część wspólna dwóch lewostronnie domkniętych przedziałów</q>.
</p>

<figure type="table" id="table:range" style="page-break-inside: auto">
    <figcaption>Interfejs klasy Range</figcaption>
    <table>
        <thead>
        <tr>
            <th>metoda</th>
            <th>opis</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>hasCommon (other)</td>
            <td>zwraca <em>true</em> jeżeli przedziały mają część wspólną</td>
        </tr>
        <tr>
            <td>isBefore (other, touch=false)</td>
            <td>zwraca <em>true</em> jeżeli koniec piewszego przedziału jest mniejszy niż początek drugiego przedziału.
                Jeżeli flaga <em>touch</em> jest równa <em>true</em>, to dodatkowo zwraca <em>true</em>, jeżeli koniec
                pierwszego przedziału jest równy początkowi drugiego przdziału oraz oba przedziały mają zamkniętą
                styczną krawędź.
            </td>
        </tr>
        <tr>
            <td>isAfter (other, touch=false)</td>
            <td>zwraca <em>true</em> jeżeli początek piewszego przedziału jest większy niż koniec drugiego przedziału.
                Jeżeli flaga <em>touch</em> jest równa <em>true</em>, to dodatkowo zwraca <em>true</em>, jeżeli początek
                pierwszego przedziału jest równy końcowi drugiego przdziału oraz oba przedziały mają zamkniętą
                styczną krawędź.
            </td>
        </tr>
        <tr>
            <td>expandToFitPrecision (precision)</td>
            <td>
                rozszerza granice przedziału, by obie krawędzie były wielokrotnością wartości <em>precision</em>
            </td>
        </tr>
        <tr>
            <td>extend (value)</td>
            <td>
                rozszerza granice przedziału o zadaną wartość w każdą ze stron
            </td>
        </tr>
        <tr>
            <td>length ()</td>
            <td>
                zwraca długość przedziału
            </td>
        </tr>
        <tr>
            <td>equals (other)</td>
            <td>
                zwraca <em>true</em>, jeżeli drugi przedział ma te same wartości oraz typy krawędzi
            </td>
        </tr>


        </tbody>
    </table>
</figure>

<p>
    Najważniejsze operacje wykonuje się jednak nie na poszczególnym przedziale, ale na zbiorze tych przedziałów.
    Wyróżnia się działania na zbiorach przedziałów, jak sumowanie dwóch zbiorów, iloczyn, różnica czy instrukcje
    przekształcające, zilustrowane na obrazku <a href="#picture:algebra"></a>.
    Instrukcja przekształcająca jest to informacja o krokach potrzebnych do przekształcenia jednego zbioru w drugi:
    które przedziały należy usunąć, którym zmienić swoje granice, a które przedziały trzeba dodać do zbioru.

</p>
<p>
    Ciekawszą częścią implementacji jest reguła porównywania danych podczas operacji, która na przykład nie pozwoli na
    scalenie przedziałów dotyczących różnych poziomach agregacji podczas operacji sumowania.
</p>

<figure type="picture" id="picture:algebra">
    <figcaption>Ilustracja operacji algebraicznych. A+B &mdash; suma, A-B &mdash; różnica, A*B &mdash; iloczyn, AΔB &mdash;
        przekształcenie.
    </figcaption>
    <img src="cache/algebra-operations.png" height="300"/>
</figure>

<h2>Przeliczanie projekcji</h2>

<p note="ten algorytm Front, Back, THIS, i tak dalej"></p>


<!--


fajny rysunek: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_89

zainspirować się błędnym, ale zrobionym diagramem: https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_8

nawiązać do frameworków react i angular w kwestii obliczania diffów do efektywnego zarządzaniem UI.
        Nie możemy po prostu liczyć diffów z całego zbioru (tak jak to robi react) w celu przebudowania UI, musimy
        liczyć diff w locie.
        React źle znosi liczenie wielkich diffów (gdyby w ten sposób deklarować renderowanie big data).
        Big data - cache może być wielki (długo działająca aplikacja), więc przeliczanie diffow nie wchodzi w rachubę.

<pre>
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓        ┏━━━━━┓        ┏━━━━━┓        │
    │   1     2        3     4        5     6        │
    ├ T                                              │
    │                                                │
    ├ B                                              │
    │                                                │
    ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
    │   0                                         7  │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    ├ F ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 1 2 3 4 5 6 │
    ├ T ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    ├ B │
    │ │
    ├ R ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ ┏━━━━━┓ │
    │ 0 1 2 3 4 5 6 7 │
    └────────────────────────────────────────────────┘
</pre>
<figure type="code" id="code:demo1">
    <pre>
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T                                              │
        │                                                │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  │
        │   0                                         7  │
        └────────────────────────────────────────────────┘
        ┌────────────────────────────────────────────────┐
        ├ F       ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓        │
        │         1     2     3     4     5     6        │
        ├ T ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        ├ B                                              │
        │                                                │
        ├ R ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓     ┏━━━━━┓  │
        │   0     1     2     3     4     5     6     7  │
        └────────────────────────────────────────────────┘
    </pre>
</figure>



<p helper="z konwersacji">
    [11:47 AM] Adam Borowski [Atlassian]: algorytmy ktore mi zajely duzo czasu to operacje UNION oraz SUBTRACT na takiej
    strukturze jak zbiór przedziałów (interval set).
    Same operacje są banalne, i są biblioteki na to, ale to co stanowi wyzwanie to obliczenie kroków transformacji
    pierwszego zbioru, aby stał się tym drugim  ( w czasie liniowym). To jest rodzaj algorytmu DIFF ale tworzony podczas
    wykonywania samej operacji UNION i SUBTRACT.
    Przykładowy test który może to ilustruje:
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('0 1 1 10'), rng('2 6 9 10 13 20'))).to.deep.equal({
    added: rng('6 9'),
    removed: [],
    resized: rng('[1 10->2]'),
    result: rng('[0 1] [1 10->2] 6 9')
    });
    [11:47 AM] Adam Borowski [Atlassian]:
    expect(DiffRangeSet.subtract(rng('2 6 7 17 18 28'), rng('0 7 7 12 12 13'))).to.deep.equal({
    added: [],
    removed: rng('2 6'),
    resized: rng('[7->13 17]'),
    result: rng('[7->13 17] [18 28]')
    });
    [11:50 AM] Adam Borowski [Atlassian]: rysuneczek dla operacij C=A-B
    [11:50 AM] Adam Borowski [Atlassian]:
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 4 7 10 20 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━━━━━━━┓ │
    │ 2 8 10 13 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ │
    │ 1 2 13 20 │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
    [11:52 AM] Adam Borowski [Atlassian]: w tym przypadku algorytm zwraca oprocz samego wyniku C=A-B inofrmacje:
    [1 2] pozostaje bez zmian
    [4 7] rozszerza się do [2 8]
    [10 20] zwęża się do [13 20]
    [11:53 AM] Adam Borowski [Atlassian]: sorki ze Ci spamuje ale jak juz tlumacze to te notatki sobie wkleje roboczo do
    magisterki zeby z tego podrozdzial zrobic
    [11:56 AM] Adam Borowski [Atlassian]: oczywiscie to dziala dla wszystkich case, na przykład gdy przedział z B
    rozdziela jeden przdział z A na dwa przedziały
    [11:56 AM] Adam Borowski [Atlassian]:
    ┌────────────────────────────────────────────────────────────────────────────────────────────────┐
    ├ A ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 11 14 15 │
    ├ B ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ ┏━━━━━━━━━━━┓ │
    │ 2 7 9 11 │
    ├ C ┏━━━━━┓ ┏━━━━━━━━━━━┓ ┏━━━━━┓ │
    │ 1 2 7 9 14 15 │
    └────────────────────────────────────────────────────────────────────────────────────────────────┘
    [12:00 PM] Adam Borowski [Atlassian]: a odpowiedź algorytmu taka:
    [12:00 PM] Adam Borowski [Atlassian]:
    {
    "result": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    },
    {
    "start": 7,
    "end": 9
    },
    {
    "start": 14,
    "end": 15,
    "existing": {
    "start": 14,
    "end": 15
    }
    }
    ],
    "added": [
    {
    "start": 7,
    "end": 9
    }
    ],
    "removed": [],
    "resized": [
    {
    "start": 1,
    "end": 2,
    "existing": {
    "start": 1,
    "end": 11
    }
    }
    ]
    }
</p>


-->

<h2 id="chapter:implementation-adapter">Adapter komponentu wykresu</h2>
<p note="chodzi o wykresy i ich aktualizacje oraz interfejsy <q>patch</q> (visjs) i <q>replace</q> (flot)">
    (pseudokod adaptera?)
</p>

<!--

TODO: rozważanie o sposobie powiadamiania klienta o zmianach danych
<ul>
    <li>powiadomienie, że gdzieś coś się zmieniło, wtedy użytkownik albo sam robi diffa, albo resetuje komponent
        wykresów. to może powodować bad UX, migotanie, itd
    </li>
    <li>powiadomienie o dokładnych zmianach. instrukcja co krok po kroku należy zmienić, aby przejść ze stanu obecnego
        do wyjsciowego. minimalizacja liczby kroków.
        Jaki fragment danych z wykresu usunąć ( z jakiej warstwy).
        Jaki fragment danych z wykresu poszerzyć (z jakiej warstwy).
        Jaki fragment do danych z wykresu dodać (z jakiej warstwy).
        Common pattern byłby taki, że albo każda seria to inna warstwa, albo jedna seria ma punkty ze wszystkich warstw.
    </li>
</ul>
<figure type="code">
    <code class="javascript">
        class ExampleZingAdapter extends ClientProxyAdapter{
        processChange(diff) {
        // diff.added, diff.removed, diff.resized -- > {layer:[Number], start, end}
for(var removedRange of diff.removed){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
for(var addedRange of diff.added){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
}
}
</code>
</figure>
-->


<p helper="">
    problemy implementacyjne https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_27
</p>


<h2>Wraper dla agregacji</h2>

<!--
Konieczność wrapperdisplay cache i translacja data-projection-data

implementacja: Skale zwyczajowe (użytkowe np dzień 12, tydzień 53, miesiąc, etc) nie robią problemu u mnie, bo każda
            agregacja ma parametr czas otwarcia i czas zamknięcia okresu który reprezentują. Żadną agregacja nie musi
            być wielokrotnościa poprzedniej, bo punkty agregacji są niezależne pomiędzy warstwami.
            Dopiero CacheProjection dobiera sobie agregację do zakresów czasu, ale znowu, każda agregacja ma wpisany
            czas za który odpowiada.
-->

<h2>Problemy z integracją z bibliotekami</h2>
<ul>
    <li>ZingChart
        * obfuscowany kod, debugging, errory...
        * beznadziejne API globalnych komend, nie da się niektórych rzeczy łatwo uzyskać ustawić
        * chyba wypełniad dziury między date.getTime() a date.getTime() co trwa bardzo długo... alokacja kilkadziesiat sekund - nie można przyczyny normalnie zdebugować
        * brak normalnego pan&zoom
        * jakieś dziwne przeliczenia iteracja po dziedzinie co "1" - od jednej daty do drugiej może minąć dużo czasu -
        to jednoznacznie dyskwalifikuje - dzieje się to w momencie gdy następuje zmiana zakresu wyświetlanego
    </li>
</ul>
<h2>Wykorzystane narzędzia i środowiska</h2>

<p helper="prezentacja 2">
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_39
</p>
<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

</p>

<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>


<h2>DynamicProjection</h2>

<p helper>

    przełączanie się,
    range scoped event
    opisać kafelkowanie zakresu danych (żeby predyktor nie doładowywał małych słupków podczas smooth paningu
    Nakładanie się warstw o dynamicznej zawartosci, jak w nakładaniu obrazów. Niemożliwe prxerysowywanie od
    początku, tylko minimalne fragmenty. Wyliczanie tych fragmentów stanowi trudność.
</p>


<figure type="picture" id="picture:dynamic-projection">
    <figcaption>Diagram pokazujący zwielokrotnienie modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/serie-cache-diagram.png">
</figure>




<h2>Modele predykcji</h2>

<p note="zaimplementowane modele predykcji" helper>
    implementacja: prediction models i dynamicProjection - paddingi, <strong>tiles</strong> muszą być sensownie dopasowane,
    żeby np wykres nie byl co chwile przerysowany, bo jakis drobnostkowy model predykcji co chwile aktualizuje
    mały kawałeczek
</p>
