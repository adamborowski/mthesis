<h1 id="chapter:implementation">Implementacja</h1>

<p>
    Niniejszy rozdział stanowi uzupełnienie do rozdziału <a href="#chapter:solution"></a>, wyjaśniające zasadę działania
    ważniejszych elementów proponowanego w tej pracy rozwiązania problemu płynnej i nieograniczonej wizualnej
    eksploracji danych pomiarowych.
</p>
<p>
    Zastosowanie biblioteki <em>ExploreJS</em> w praktyce pozwala na:
</p>
<ul>
    <li>wyświetlanie wielu komponentów wykresów jednocześnie,</li>
    <li>wyświetlanie tej samej serii danych w różnych wykresach, w dowolnych zakresach,</li>
    <li>wyświetlanie wielu serii na jednym wykresie.</li>
</ul>

<p>
    By wydajnie wspierać powyższe funkcje, <em>ExploreJS</em> maksymalizuje współdzielenie zasobów w ramach całej
    aplikacji w przeglądarce:
</p>
<ul>
    <li>wszystkie zapytania o dane do serwera są zarządzane przez jeden moduł <em>ReqestManager</em>,</li>
    <li>moduł <em>CacheManager</em> powiela moduł <em>SerieCache</em> (odpowiedzialny za pamięć podręczną serii i
        projekcje warstw) dla każdej serii danych,
    </li>
    <li>moduł <em>DataSource</em> tworzony jest dla każdego komponentu wykresu osobno.</li>
</ul>

<p>
    Diagram <a href="#picture:architecture"></a> pokazuje przykładowe ustawienie modułów dla aplikacji z trzema
    wykresami, gdzie pierwszy oraz trzeci wyświetlają dane z tej samej serii danych pomiarowych.
</p>

<p>
    Każdy komponent wykresowy podłączony jest do swojego <em>DataSource</em> poprzez adapter specyficzny dla danego typu
    komponentu (oznaczony symbolem interfejsu).
    Informuje o interakcji użytkownika oraz przyjmuje nowe dane do aktualizacji.
</p>

<p>
    Każda instancja <em>DataSource</em> posiada inny zestaw modeli predykcji, w związku z czym silnik predykcji, zawarty
    w każdej instancji <em>DataSource</em> może reagować na interakcję użytkownika inaczej.
    Każda z siedmiu instancji modelu predykcji niezależnie odwołuje się do pamięci podręcznej adekwatnej serii danych.
</p>

<p>
    Wewnątrz instancji <em>DataSource</em> umieszczone są instancje <em>DynamicProjection</em>, które szczegółowo
    opisane są w dalszej części tego rozdziału.
</p>

<p>
    Moduł <em>CacheManager</em> zarządza instancjami <em>SerieCache</em>, których zadaniem jest obsługa wielowarstwowej
    pamięci podręcznej oraz jej projekcji, opisanej w rozdziale <a href="#chapter:multilayer-cache"></a>.
</p>

<p>
    Moduł <em>RequestManager</em> obsługuje żądania z pamięci <em>cache</em> wszystkich serii danych, grupuje je w
    większe paczki, wysyła je do serwera danych, a odpowiedź rozpakowuje i rozsyła do adektwatnych instancji <em>SerieCache</em>.
</p>

<p>
    Serwer REST implementuje uzgodniony format JSON zapytania i odpowiedzi, odpytuje serwer danych lub bezpośrednio bazę danych.
</p>


<figure type="picture" id="picture:architecture">
    <figcaption>Diagram pokazujący liczebność instancji modułów i ich wzajemne oddziaływania.
        Kolorem zielonym oznaczono moduły <em>ExploreJS</em>, żółtym zaś pozostałe elementy systemu.
    </figcaption>
    <img src="cache/client-architecture.png">
</figure>



<h2>Komunikacja z serwerem REST</h2>

<p>
    Biblioteka <em>ExploreJS</em> jest niezależna od wykorzystywanego oprogramowania po stronie serwera.

    Należy jednak pamiętać, że serwer danych musi udostępniać dane zagregowane w miarę równomiernie rozłożonymi
    poziomami agregacji, jak jest to opisane w rozdziale <a href="#chapter:data-reduction"></a>.

</p>

<p>
    Serwis REST udostępniać musi dwa zasoby.

    Ich ścieżka jest konfigurowalna podczas inicjalizacji <em>ExploreJS</em>.

    Pierwszym zasobem jest <code>GET /manifest</code>, drugim <code>POST /batch</code>.

    Tutaj nasuwa się pytanie, dlaczego serwis odczytujący dane obsługuje metodę <code>POST</code>, służącą zwyczajowo do
    dodawania nowych zasobów do serwera.

    Zapytanie <code>batch</code> zawiera dane w swoim ciele <trans lang="ang">request body</trans>.

    Mimo, że właściwa do tego zastosowania metoda <code>GET</code> oficjalnie wspiera <trans> request body</trans>, to
    implementacje wielu systemów się tego nie spodziewają.

    By uniknąć problemów z wycinaniem tej części zapytania przez systemy <em>firewall</em> lub mechanizm filtrów w <em>JAVA
    Enterprise</em>, stosuje się wyjątkowo metodę POST.
</p>

<h3>Manifest danych pomiarowych</h3>
<p>
    Podczas inicjalizacji <em>ExploreJS</em> w aplikacji w przeglądarce, do serwera zostaje wysłane zapytanie
    <code>GET /manifest</code>, które zawiera ważne z punktu widzenia biblioteki informacje o udostępnianych danych
    (pokazane na listingu <a href="#code:manifest"></a> ).
    Dla każdej serii danych pomiarowych zwracany jest:
</p>
<ul>
    <li>identyfikator serii,</li>
    <li>początek i koniec zakresu wszystkich dostępnych danych,</li>
    <li>informację o udostępnianych poziomach agregacji, gdzie dla każdego poziomu zdefiniowane są:
        <ul>
            <li>identyfikator agregacji,</li>
            <li>długość okresu agregowania.</li>
        </ul>
    </li>
</ul>

<figure type="code" id="code:manifest">
    <figcaption>Przykładowa odpowiedź manifestu danych</figcaption>
    <pre><code class="json">
{ "series":[
      {
         "start": 1317427200000, // 2011-10-01
         "end": 1496880000000,   // 2017-06-08
         "serieId": "AM01_NOX",  // stężenie tlenku azotu na stacji pomiarowej numer 1
         "levels":[
            { "id": "30s", "step": 30000 },
            { "id": "1m", "step": 60000 },
            [...]
            { "id": "90d", "step": 7776000000 },
            { "id": "1y", "step": 31536000000 }
         ]
      },
      [...]
] }</code></pre>
</figure>

<p>
    Dzięki manifestowi wiadomo, jakie są dostępne poziomy agregacji.
    Jest to niezbędne do wyznaczania odpowiedniego poziomu agregacji do wyświetlenia.
    Manifest również jest używany przez modele predykcji.
</p>

<p>
    Po pobraniu manifestu zostają utworzone instancje <em>SerieCache</em> odpowiedzialne za obsługę pamięci
    <em>cache</em> oraz jej projekcji.
</p>

<p>
    Ważne jest również to, że w celu uproszczenia rozwiązania, dane surowe są traktowane przez <em>ExploreJS</em>
    również jako agregacje danych. Z punktu widzenia działania mechanizmów wewnątrz <em>ExploreJS</em> nie ma
    rozróżnienia między danymi surowymi a agregacjami tych danych. Przyjmuje się, że dane surowe oznacza się
    identyfikatorem <q>raw</q> o długości agregowanego zakresu odpowiadającej średniej częstości zbierania tych danych.
    Dla danych monitoringu jakości powietrza będzie to okres <em>10s</em>, dla danych medycznych przykładowo
    <em>50ms</em>. Rozróżnienie danych surowych od agregacji jest istotne dopiero przy wyświetlaniu danych na wykresie,
    co zostało omówione w rozdziale <a href="#chapter:implementation-adapter"></a>.
</p>

<h3>Grupowe zapytania o dane</h3>

<p>
    Drugim typem zapytań są zapytania o same dane pomiarowe.

    Zapytanie jest tak naprawdę paczką zapytań, zgrupowanych przez moduł <em>RequestManager</em>.

    W ciele zapytania <code>POST /batch</code> znajduje się zbiór żądań o dane z różnych serii, różnych poziomów
    agregacji oraz różnych zakresów danych, jak pokazano na listingu <a href="#code:batch"></a>.
</p>

<figure type="code" id="code:batch">
    <figcaption>Przykładowe ciało grupowego żądania o dane</figcaption>
    <pre><code class="json">
[ {
    "id": "AM01_NOX",     // stężenie tlenku azotu na stacji pomiarowej numer 1
    "level": "1h",        // agregacje godzinne
    "from": 772088888908, // zakres od 1994-06-20 05:08:08 włącznie
    "to": 783760000000    // zakres do 1994-11-02 07:06:40 włącznie
  },
  {
    "id": "AM01_NOX",
    "level": "1h",
    "from": 808000000000,
    "to": 825955555576
  },
  {
    "id": "AM01_NOX",
    "level": "4h",        // agregacje czterogodzinne
    "from": 776090016000,
    "to": 776625062400
} ]</code></pre>
</figure>

<p>
    Struktura odpowiedzi jest bardzo podobna do żądania. Różnica jest w tym, że odpowiedź dla każdego żądania zawiera
    pole o nazwie <q>data</q> będące tablicą danych. Każdy punkt danych w tabeli posiada pola obowiązkowe o nazwach
    zaczynających się znakiem <code>$</code>.
    Są to pola <code>$s</code> oraz <code>$e</code> zawierające stempel czasowy odpowiednio początku i końca zakresu
    agregacji. Jeśli jest to punkt przedstawiający nie agregację, lecz surowy punkt pomiarowy, polem obowiązkowym jest
    pole <code>$t</code> oznaczające stempel czasowy próbki.
    Pozostałe pola traktowane są jako agregowane wartości i nie są wykorzystywane przez <em>ExploreJS</em>.
    Dopiero adapter wykresu przy wyświetlaniu punktu interpretuje we właściwy sposób te dane. Struktura przykładowego
    punktu została pokazana na listingu <a href="#code:batch-response"></a>.
</p>

<figure type="code" id="code:batch-response">
    <figcaption>Pojedynczy punkt danych w odpowiedzi serwera.</figcaption>

    <pre><code>
{
  "$e": 795301200000,    // początek agregacji
  "$s": 795297600000,    // koniec agregacji
  "a": 1698.85061111111, // wartość średnia pomiaru
  "b": 1666.49,          // wartość minimalna pomiaru
  "t": 1733.55,          // wartość maksymalna pomiaru
  "c": 360               // liczba zliczonych punktów pomiaru
}</code></pre>

</figure>

<h3>Optymalizacja zapytań</h3>
<p>
    Ze względu na dużą dynamikę wizualnej eksploracji danych pomiarowych, żądania wychodzące z mechanizmu predykcji
    generowane są dosyć częstwoi nakładają się w małych przedziałach czasowych. Co więcej, zakresy tych zapytań często
    mają niemałą część wspólną.
</p>

<p>
    Początkowa implementacja, która nie łączyła zapytań, generowała osobne żądania w takiej liczbie, że ich liczba
    namnażała się tworząc wydłużającą się kolejkę w przeglądarce <a href="#bib:browser-request-limits"></a>.

    By rozwiązać ten problem, należało na poziomie fizycznym i logicznym łączyć te zapytania.
</p>

<p>
    Łączenie fizyczne polega na wydzieleniu krótkiego odcinka czasu, w którym żądania zgłaszane do
    <em>RequestManagera</em> odkładane są do specjalnego bufora. Po upływie ustalonego czasu, zgłoszenia z bufora
    pakowane są do pojedynczego żądania <em>AJAX</em>, wysyłane do serwera, a bufor zostaje wyczyszczony. Zostało to
    zilustrowane na obrazku <a href="#picture:physical-merging"></a>.

</p>

<figure type="picture" id="picture:physical-merging">
    <figcaption>Buforowanie zapytań do <em>RequestManagera</em>. Po upływie ustalonego czasu zbuforowane zapytania
        łączone są w
        paczkę i wysyłane przez AJAX.
    </figcaption>
    <img src="cache/physical-merging.png"/>
</figure>

<p>
    Łączenie fizyczne pozwoliło na zmniejszenie liczby jednoczesnych żądań do serwera, natomiast nie rozwiązało to
    problemu, że w jednej paczce znajdowały się zapytania, których zakresy mają część wspólną, co powodowało pobieranie
    nadmiernej ilości danych, co jest sprzeczne z celem <em>ExploreJS</em>. Usunięciem tej redundancji zajmuje się
    specjalny moduł <em>MergingBatch</em> wewnątrz <em>RequestManagera</em>, który zajmuje się logicznym łączeniem żądań
    do serwera.
</p>

<p>
    Moduł scalający <em>MergingBatch</em> w zawansowany sposób łączy żądania w buforze zapytań.
    Zamiast dodawać zapytanie do listy żądań, znajduje wpierw istniejące żądania dla tej samej serii i poziomu
    agregacji i próbuje scalić te żądania z nowym żądaniem.
    W wyniku tego zamiast tworzenia kolejnego żądania, może się zmienić zakres innego, a nawet zmniejszyć liczba żądań.
    Zostało to zademonstrowane na rysunku <a href="#picture:logical-merging"></a>.
</p>

<figure type="picture" id="picture:logical-merging">
    <figcaption>Wizualizacja scalania żądań. Żądania dotyczące tej samej serii i poziomu agregacji oznaczono jednym
        kolorem.
    </figcaption>
    <img src="cache/logical-merging.png" height="300"/>
</figure>

<p>
    W tym przypadku w buforze istniały zapytania, z czego jedno dotyczyło serii danych <em>Y</em>, pozostałe <em>X</em>.
    Podczas dodawania nowego żądania o dane serii <em>X</em>, dla agregacji godzinnej, okazało się, że w buforze
    znajdują się inne żądania agregacji godzinnych tej serii. Po scaleniu tych żądań z dodawanym żądaniem, okazuje się,
    że wszystkie trzy żądania mają część wspólną, zatem zostały zastąpione jednym żądaniem.
</p>

<p>
    Moduł <em>MergingBatch</em> rozwiązuje jeszcze jeden problem.

    O ile powyższe łączenie scala żądania z tymi znajdującymi się w buforze, to nie są brane pod uwagę trwające żądania,
    które zostały wysłane do serwera.

    Może to spowodować podwójne ładowanie danych z tego powodu, że pierwsze żądanie opuściło już bufor, ale dane jeszcze
    nie zostały umieszczone w pamięci cache.

    W związku z tym <em>MergingBatch</em> tworzy dodatkowy bufor na trwające żądania.

    Podczas dodawania nowego żądania, zanim dojdzie do scalania z buforem oczekujących żądań, dochodzi do operacji
    odejmowania zakresów z bufora trwających żądań od nowego żądania.
</p>
<p>
    Całą zasadę działania <em>MergingBatch</em> na żądaniach dotyczących tej samej serii i poziomu agregacji można
    wyrazić odpowiednimi operacjami na przedziałach, przedstawionych wzorem <a href="#code:merging-batch"></a>.
</p>


<figure type="code" id="code:merging-batch">
    <figcaption>Łączenie zbiorów w <em>MergingBatch</em>. <em>A</em> oznacza nowe zgłoszenie, <em>P</em> - bufor
        trwających zgłoszeń, <em>Q<sub>1</sub></em> - bufor oczekujących zgłoszeń,
        <em>Q<sub>2</sub></em> - bufor oczekujących zgłoszeń po dodaniu noweg zgłoszenia.
    </figcaption>
    <pre class="math">
        Q<sub>2</sub> = Q<sub>1</sub> + ({A} - P)
    </pre>
</figure>


<p>
    Dzięki zastosowaniu <em>MergingBatch</em> nie istnieje możliwość, że serwer będzie pytany o nakładające się zakresy
    w krótkim czasie, co maksymalnie optymalizuje komunikację <em>ExploreJS</em> z serwrem.
</p>


<h2 id="chapter:rangealgebra">Algebra przedziałów i operacje przekształcające</h2>

<p>
    Algorytmy i struktury danych używane w implementacji rozwiązania w głównej mierze opierają się na algebrze
    przedziałów. Wykorzystuje się ją w takich miejscach, jak:
</p>

<ul>
    <li>scalanie żądań przez <em>MergingBatch</em></li>
    <li>operacje na pamięci podręcznej</li>
    <li>aktualizacja projekcji <em>cache</em></li>
    <li>implementacja czasowego modelu zdarzeniowego (opisane później)</li>
    <li>modele predykcji</li>
    <li>dobór zakresu danych w <em>DataSource</em></li><!--(DynamicProjection)-->
</ul>

<p>
    W celu usystematyzowania implementacji wprowadzono strukturę danych <em>Range</em>.

    Jest przedział o dowolnym domknięciu przechowujący wartość &mdash;
    np. <code><2016-05-04 11:00, 2016-05-04 14:00)</code> o wartości <code>{min:2, max:4, avg:2.23}</code>

    <em>Range</em> udostępnia metody do wyrażania wzajemnych zależności, co zostało przedstawione w
    tabeli <a href="#table:range"></a>. Ważną cechą implementacyjną jest to, że przy obliczaniu zależności brane są pod
    uwagę typy brzegów, na przykład <q>część wspólna dwóch lewostronnie domkniętych przedziałów</q>.
</p>

<figure type="table" id="table:range" style="page-break-inside: auto">
    <figcaption>Interfejs klasy Range</figcaption>
    <table>
        <thead>
        <tr>
            <th>metoda</th>
            <th>opis</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>hasCommon (other)</td>
            <td>zwraca <em>true</em> jeżeli przedziały mają część wspólną</td>
        </tr>
        <tr>
            <td>isBefore (other, touch=false)</td>
            <td>zwraca <em>true</em> jeżeli koniec piewszego przedziału jest mniejszy niż początek drugiego przedziału.
                Jeżeli flaga <em>touch</em> jest równa <em>true</em>, to dodatkowo zwraca <em>true</em>, jeżeli koniec
                pierwszego przedziału jest równy początkowi drugiego przdziału oraz oba przedziały mają zamkniętą
                styczną krawędź.
            </td>
        </tr>
        <tr>
            <td>isAfter (other, touch=false)</td>
            <td>zwraca <em>true</em> jeżeli początek piewszego przedziału jest większy niż koniec drugiego przedziału.
                Jeżeli flaga <em>touch</em> jest równa <em>true</em>, to dodatkowo zwraca <em>true</em>, jeżeli początek
                pierwszego przedziału jest równy końcowi drugiego przdziału oraz oba przedziały mają zamkniętą
                styczną krawędź.
            </td>
        </tr>
        <tr>
            <td>expandToFit (precision)</td>
            <td>
                rozszerza przedział tak, by obie krawędzie były wielokrotnością danej wartości
            </td>
        </tr>
        <tr>
            <td>extend (value)</td>
            <td>
                rozszerza granice przedziału o zadaną wartość w każdą ze stron
            </td>
        </tr>
        <tr>
            <td>length ()</td>
            <td>
                zwraca długość przedziału
            </td>
        </tr>
        <tr>
            <td>equals&nbsp;(other)</td>
            <td>
                zwraca <em>true</em>, jeżeli drugi przedział ma te same wartości oraz typy krawędzi
            </td>
        </tr>


        </tbody>
    </table>
</figure>

<p>
    Najważniejsze operacje wykonuje się jednak nie na poszczególnym przedziale, ale na zbiorze tych przedziałów.
    Wyróżnia się działania na zbiorach przedziałów, jak sumowanie dwóch zbiorów, iloczyn, różnica czy instrukcje
    przekształcające, zilustrowane na obrazku <a href="#picture:algebra"></a>.
    Instrukcja przekształcająca jest to informacja o krokach potrzebnych do przekształcenia jednego zbioru w drugi:
    które przedziały należy usunąć, którym zmienić swoje granice, a które przedziały trzeba dodać do zbioru.

</p>

<figure type="picture" id="picture:algebra">
    <figcaption>Operacje algebraiczne. A+B &mdash; suma, A-B &mdash; różnica, A*B &mdash; iloczyn, AΔB &mdash;
        przekształcenie.
    </figcaption>
    <img src="cache/algebra-operations.png" height="260"/>
</figure>

<p>
    Ważną częścią implementacji jest reguła porównywania danych podczas operacji, która między innymi nie pozwoli na
    scalenie przedziałów dotyczących różnych poziomach agregacji podczas wykonywania operacji &mdash; gdy dwa przedziały
    będą styczne, to zostaną scalone tylko wtedy, gdy dotyczą tego samego poziomu agregacji.
</p>

<h2 id="chapter:implementation-projection-recalculation">Przeliczanie projekcji</h2>
<p>
    Projekcja pamięci podręcznej opisana w rozdziale <a href="#chapter:theoretical-cache-projection"></a> wykorzystuje
    operacje na przedziałach do aktualizacji indeksów warstw. Dla przypomnienia &mdash; projekcja <em>cache</em>
    dla określonego poziomu agregacji to informacja, z jakich warstw pamięci, jakie zakresy danych użyć do wyświetlenia
    użytkownikowi możliwie najwierniejszego kształtu danych, podczas gdy czeka na dane o żądanej rozdzielczości.
</p>

<p>
    Indeks ten reprezentowany jest w formie zbioru przedziałów oznaczonych etykietą odpowiadającą poziomowi agregacji.

    Ponieważ dane pomiarowe zazwyczaj ładowane są zakresach zawierających wiele (setki czy tysiące) punktów, indeks
    opisuje tylko przedziały ciągłości danych w pamięci.
    Dla przykładu, jeżeli w pamięci <em>cache</em> na poziomie <em>1d</em> pojawi się ciąg agregacji dobowych za cały
    rok 2016, to w indeksie pojawi się nie 365, lecz tylko jeden element o zakresie początku i końca roku 2016.
    Można stwierdzić, że liczba elementów w indeksie nie zależy więc od zapełnienia pamięci podręcznej, ale od stopnia
    jej pofragmentowania.

    Na rysunku <a href="#picture:projection-index"></a> pokazano pamięć cache oraz indeksy projekcji na różnych
    poziomach, w tym samym zakresie czasu.
</p>

<figure type="picture" id="picture:projection-index">
    <figcaption>Zarys pamięci podręcznej oraz struktura projekcji danych z niższych warstw
    </figcaption>
    <img src="cache/projection-index-structure.png"/>
</figure>

<p>
    Warto pamiętać, że w aplikacji używającej <em>ExploreJS</em> może działać wiele wykresów jednoczesnie, każdy może
    mieć inny poziom przybliżenia. Jeden może wyświetlać bardziej szczegółowe agregacje (na przykład 7d), drugi mniej
    szczegółowe (na przykład 30d).
    Temu pierwszemu trzeba będzie wyświetlić dane korzystając z projekcji dla warstwy 7d, drugiemu z projekcji dla
    warstwy 30d.
    Dzięki temu drugi wykres nie będzie rysował zbyt <q>gęstych</q> danych na ekranie, podczas gdy ten pierwszy będzie
    nadal mógł je wyświetlać będąc do nich bardziej <q>przybliżony</q>.

    <em>ExploreJS</em> tworzy projekcję dla każdej warstwy <em>cache</em>, by umożliwić działanie wielu wykresów
    jednocześnie.
</p>

<p>
    Aktualizacja dowolnej warstwy pamięci podręcznej wymaga przebudowy projekcji na tej samej oraz wszystkich wyższych
    warstwach. Dla przykładu, gdy zostanie aktualizowana pamięć na warstwie <em>1h</em>, to należy przeliczyć projekcje
    na poziomie <em>1h</em>, <em>10m</em>, <em>1m</em> oraz <em>raw</em>, gdyż zmiana ta może być zauważalna. Nie ma
    sensu aktualizować projekcji <em>1d</em>, <em>7d</em>, <em>90d</em> oraz <em>1y</em>, gdyż na tych projekcjach tak
    szczegółowa warstwa, jak <em>1h</em>, nie jest uwzględniana.
</p>

<p class="keep-after">

    Samo przeliczenie projekcji można wyrazić wzorem rekurencyjnym pokazanym na listingu <a
        href="#code:recursion-projection"></a>.

</p>

<figure type="code" id="code:recursion-projection">
    <figcaption>Rekurencyjny wzór na projekcję pamięci, gdzie
        <em>P<sub>n</sub></em> oznacza projekcję na warstwie n,
        <em>L<sub>n</sub></em> oznacza indeks danych na warstwie n pamięci cache
    </figcaption>
    <pre class="math">
        P<sub>n</sub> = L<sub>n</sub> + (P<sub>n-1</sub> - L<sub>n</sub>)
        P<sub>0</sub> = L<sub>0</sub>
    </pre>
</figure>

<p>
    <em>ExploreJS</em> w praktyce nie przelicza całej projekcji za każdym razem, gdy do <em>cache</em>
    zostaną dodane nowe dane &mdash; unikaja tym samym potencjalnie czasochłonnych operacji na bardzo pofragmentowanej
    pamięci podręcznej.
    Zaprojektowany algorytm używa istniejącej projekcji i w momencie dodania nowego przedziału do pamięci podręcznej
    oblicza tylko minimalny zestaw kroków potrzebnych do przekształcenia istniejącej projekcji w nową &mdash; aktualną:
</p>

<ol>
    <li>wyznaczany jest wspólny zakres (zawierający całe przedziały) dotychczaswej projekcji oraz dodawanego przedziału
    </li>
    <li>istniejąca projekcja dzielona jest na trzy części (rysunek <a href="#picture:projection-diff-cut"></a>)</li>
    <li>na środkowej części projekcji stosuje się <em>algorytm dodania nowego przedziału</em></li>
    <li>aktualizowaną środkową cześć łączy się z powrotem z zewnętrznymi częściami projekcji</li>
</ol>

<figure type="picture" id="picture:projection-diff-cut">
    <figcaption>Wydzielenie wspólnego przedziału do aktualizacji projekcji. <em>P<sub>n</sub></em> - <q>istniejąca</q>
        projekcja, <em>R</em> - nowy przedział
    </figcaption>
    <img src="cache/projection-diff-cut.png"/>
</figure>

<p>
    <em>Algorytm dodawania nowego przedziału R</em> (Rys. <a href="#picture:projection-merge"></a>), wyodrębniony z
    poprzedniego algorytmu, w pierwszej kolejności grupuje przedziały projekcji względem ich relacji do dodawanego
    przedziału <em>R</em>:
</p>

<ul class="keep-inside keep-before">
    <li>F <trans lang="ang">front</trans> &mdash; jeżeli przedział odpowiada warstwie wyższej, niż warstwa <em>R</em>
        (<em>F</em> przykryje <em>R</em>)
    </li>
    <li>T <trans lang="ang">twin</trans> &mdash; jeżeli przedział odpowiada tej samej warstwie, co <em>R</em>
        (<em>T</em> scali się z <em>R</em>)
    </li>
    <li>B <trans lang="ang">back</trans> &mdash; jeżeli przedział odpowiada warstwie niższej, niż warstwa <em>R</em>
        (<em>B</em> schowa się pod <em>R</em>)
    </li>
</ul>

<p>
    Następnie dokonywane są operacje na tych grupach:
</p>

<ul>
    <li>grupa <em>F</em> zostaje niezmieniona &mdash; skoro przykrywa <em>R</em>, to <em>R</em> nie może jej zmienić
    </li>
    <li>do grupy <em>T</em> dodaje się przedział <em>R</em>, ale tylko te fragmenty, które nie zostały przykryte przez
        przedziały na warstwie wyższej (grupa <em>F</em>)
    </li>
    <li>od grupy <em>B</em> odejmuje się przedział <em>R</em>, jako że przedział <em>R</em> przykrywa grupę <em>B</em>
    </li>
</ul>


<figure type="picture" id="picture:projection-merge">
    <figcaption>Przykład zastosowania algorytmu dodawania nowego przedziału do projekcji</figcaption>
    <img src="cache/projection-merge.png"/>
</figure>

<p>
    Po wykonaniu powyższych operacji, grupy <em>F</em>, <em>T</em> oraz <em>B</em> zawierają rozłączne przedziały, zatem
    wystarczy przenieść je z grup do wspólnego zbioru.
</p>

<p>
    Jeżeli po przeliczeniu projekcji nastąpi faktycznie zmiana w projekcji (a tak być nie musi, jeżeli przedział
    <em>R</em> jest w
    całości przykryty przedziałem z grupy <em>F</em>), to zostaje wywołane zdarzenie informujące o tym, że dana
    projekcja została uaktualniona, w jakim zakresie oraz w jaki sposób się zmieniła (który przedział usunięto, który
    zmieniono, który dodano) &mdash; zob. rozdział <a href="#chapter:rangescopedevent"></a>.
    Dzięki temu w bardzo łatwy sposób można nasłuchiwać jakichkolwiek zmian w projekcji pamięci podręcznej na konkretnej
    warstwie, co jest wykorzystywane przez moduł <em>DynamicProjection</em>, który przedstawiony jest jako kolejny w tym
    rozdziale.
</p>

<h2>DataSource, ViewState i DynamicProjection</h2>

<p>
    Warto przypomnieć sobie, czym dokładnie jest <em>komponent wykresowy</em>, opisany w rozdziale <a
        href="#chapter:theoretical-charting-components"></a>.
    Jest to dowolny moduł programowy, który na podstawie dostarczonych danych wyświetla graficzne wykresy na ekranie
    komputera. Większość komponentów wykresowych potrafi wyświetlać podzbiór dostarczonych im danych.
    Takie komponenty zazwyczaj samodzielnie obsługują nawigację po danych, które posiadają. Przykład takiego komponentu
    został pokazany na obrazku <a href="#picture:dygraphs"></a>.
</p>

<figure type="picture" id="picture:dygraphs">
    <figcaption>Komponent wykresowy z biblioteki <em>Dygraphs</em>. Umożliwia wyświetlanie podzbioru dostarczonych
        danych, co zostało dodatkowo zaznaczone na miniaturze wykresu.
    </figcaption>
    <img src="/images/theoretical/dygraphs.png" height="200"/>
</figure>

<p>
    Problemem z takimi komponentami w kontekście nieograniczonej eksploracji danych jest to, że wiele implementacji
    bibliotek wykresowych nie działa wydajnie z dużymi zbiorami danych, nawet jeśli zakres wyświetlanych na nich danych
    jest niewielki.

    Jest to spowodowane na przykład tym, że biblioteki generują elementy <em>SVG DOM</em> dla wszystkich danych
    niezależnie od tego, czy są widoczne na ekranie czy nie.

    Te biblioteki, które obsługują duże zbiory danych, zazwyczaj posiadają własny bufor w pamięci, a widoczne fragmenty
    renderują na elemencie <em>Canvas</em>.

    Z kolei te biblioteki, które obsługują duże zbiory danych, niezawsze umożliwiają ich wydajną aktualizację.
</p>

<p>
    Aby w jednolity sposób rozwiązać wszystkie wpomniane wyżej problemy, <em>ExploreJS</em> nie dostarcza komponentowi
    danych z całego zakresu dostępnego w pamięci cache, lecz tylko fragment potrzebny w danym momencie do wyświetlenia.
    W związku z tym, że komponent wykresowy nie posiada wszystkich danych, należy sukcesywnie aktualizować mu dane,
    niejako podążając za użytkownikiem, który może mieniać zakres danych na wykresie.
</p>

<p>
    W sytuacji, gdy aktualizuje się dane w komponencie w momencie każdej zmiany zakresu, pojawia się problem
    wydajnościowy, jeśli komponent wykresowy umożliwia płynną zmianę zakresu &mdash; albo poprzez animację, albo przez
    <q>przesuwanie
        wykresu myszką</q> &mdash; w każdej klatce animacji nastąpi bowiem aktualizacja komponentu wykresowego (Rys. <a
        href="#picture:datasource-tiling"></a> A).

    Niestety &mdash; sporo bibliotek nie wspiera dobrze takiego przypadku i komponent nie działa wtedy płynnie, co mija
    się
    niejako z założeniami proponowanego rozwiązania.
</p>

<p>
    <em>ExploreJS</em> rozwiązuje ten problem poprzez <em>kafelkowanie</em> zakresu (Rys. <a
        href="#picture:datasource-tiling"></a> B).
    Oznacza to, że zakres danych dostarczanych do komponentu musi być zawsze dopasowany do kafli o danym rozmiarze,
    rozłożonych na całej przestrzeni &mdash; zakres nie może dzielić żadnego kafla.
    W praktyce oznacza to, że zakres wyświetlanych danych musi zostać rozszerzony, aby jego krawędzie miały wartości
    będące wielokrotnością szerokości kafla.

    Znacznie redukuje to liczbę potrzebnych aktualizacji, ponieważ wszystkie widoczne zakresy nachodzące na te same
    kafle nie będą wymagały aktualizacji.

    Kosztem rozwązania tego problemu jest przesyłanie niewiele większego zakresu danych do komponentu.
    Manipulując szerokością kafla można sterować balansem pomiędzy częstotliwością aktualizacji komponentu a wielkością
    zakresu przesyłanych danych.

    W <em>ExploreJS</em> domyślną szerokością kafla jest wartość równa szerokości wyświetlanego zakresu, a jednorazowo
    do komponentu zostają przekazane trzy <q>kafle</q>.
    To znaczy, że jeżeli użytkownik przesunie zakres o 5 <q>szerokości</q> wykresu, to komponent wykresu zostanie
    aktualizowany nowym fragmentem pamięci podręcznej tylko 5 razy.
</p>


<figure type="picture" id="picture:datasource-tiling">
    <figcaption>
        Zakresy dostarczanych danych (czerwone ramki) do komponentu podczas płynnego przesuwania zakresu w prawo.
        Przezroczystość ramek oznacza upływ czasu.
        <em>A</em> &mdash; zakres identyczny z widzianym zakresem, <em>B</em> &mdash; zakres dopasowany do <q>kafli</q>.

    </figcaption>
    <img src="cache/datasource-tiling.png" width="88%"/>
</figure>


<p>
    O ile kafelkowanie zakresów sprawdza się przy płynnych ruchach horyzontalnych zakresu, to nie rozwiązuje ono
    problemu zbyt częstej aktualizacji wykresu w momencie płynnego przybliżania/oddalania.

    Jest to spowodowane każdorazową nieznaczną zmianą definicji kafla, która zależy od płynnie zmieniającej się wtedy
    skali
    wykresu, bowiem wyrażana jest w jednostce zakresów &mdash; czyli czasu.

    Każda zmiana definicji kafla powoduje to, że zaprezentowany algorytm kafelkowania uznaje niedopasowanie aktualnego
    zakresu przesłanych danych do nowego zakresu. Pokazano to na rysunku <a href="#picture:datasource-tiling-scale"></a>.
</p>

<figure type="picture" id="picture:datasource-tiling-scale">
    <figcaption>
        Zakresy dostarczanych danych (czerwone ramki) do komponentu podczas płynnego
        przybliżania. Przezroczystość ramek oznacza upływ czasu.
    </figcaption>
    <img src="cache/datasource-tiling-scale.png" width="88%"/>
</figure>

<p>
    Aby nie aktualizować wykresu w takiej sytuacji niepotrzebnie, wprowadzono poprawkę do algorytmu aktualizacji danych
    &mdash;
    jeżeli obecny zakres danych w komponencie pokrywa nowy zakres widziany przez użytkownika - aktualizacja danych nie
    następuje &mdash; mimo, iż zakres nie pasuje do nowej definicji kafla.

    W praktyce &mdash; do wymaganego przy porównaniu zakresu dodaje się margines wynoszący 10% szerokości ekranu, ze
    względu na implementacje bibliotek wykresowych, które potrzebują kawałka danych spoza wyświetlanego obszaru do
    zachowania ciągłości wyświetlanych danych oraz poprawnej nawigacji &mdash; niektóre biblioteki, na przykład, nie
    pozwalają na <q>wyjście</q> poza obszary pokryte danymi.
</p>

<p class="keep-after keep-inside">
    Za opisane wyżej zadania przekazywania fragmentu pamięci <em>cache</em> do komponentu wykresu odpowiada moduł <em>DataSource</em>.
    Zadania te deleguje do podmodułów <em>ViewState</em> oraz <em>DynamicProjection</em>.
    Na schemacie <a href="#picture:dynamic-projection"></a> pokazano zależność tych modułów z pozostałymi modułami
    <em>ExploreJS</em>.
</p>

<figure type="picture" id="picture:dynamic-projection">
    <figcaption>Diagram pokazujący zależności między pamięcią podręczną a <em>DataSource</em></figcaption>
    <img src="cache/serie-cache-diagram.png" width="88%">
</figure>


<p>
    <em>ViewState</em> odpowiada za przechowywanie aktualnego stanu komponentu: wyświetlanego zakresu, szerokości
    komponentu na ekranie oraz oczekiwanego poziomu agregacji. Moduł ten również wywołuje zdarzenie informujące o
    każdorazowej zmianie stanu.
</p>

<p>
    Moduł <em>DynamicProjection</em> odpowiedzialny jest za powiadamianie <em>DataSource</em>, kiedy i w jaki sposób
    należy aktualizować komponent wykresu.
    Powiadomienia pochodzące od <em>DynamicProjection</em> są jedynym źródłem informacji o konieczności aktualizacji
    komponentu wykresu. Powiadomienia te wywoływane są wtedy, gdy:
</p>

<ul>
    <li>należy podmienić <q>kafle</q> pamięci <em>cache</em> na skutek przemieszczania się wyświetlanego zakresu na
        wykresie
    </li>
    <li>
        należy zmienić poziom szczegółowości na skutek rozszerzenia/zwężenia wyświetlanego zakresu
    </li>
    <li>
        we fragmencie pamięci podręcznej, który został skopiowany do komponentu, pojawią się nowe dane (synchronizacja)
    </li>
</ul>

<h3>Zmiana stanu <em>ViewState</em></h3>

<p>

    Moduł <em>DynamicProjection</em> nasłuchuje zdarzenia emitowanego przez <em>ViewState</em>.
    W momencie zmiany stanu sprawdzane są następujące warunki, gdzie każdy z nich:
</p>

<ul>
    <li>czy to jest pierwsze zdarzenie dla tej instancji <em>ViewState</em> (inicjalne przekazanie danych)</li>
    <li>czy należy wymienić <q>kafle</q> danych z pamięci podręcznej (opisane wcześniej w tym rozdziale)</li>
    <li>czy nastąpiła zmiana oczekiwanego poziomu agregacji (w wyniku przybliżania/oddalania)</li>
</ul>

<p>
    Jeżeli którekolwiek warunek jest spełniony - następuje wyznaczenie nowego zakresu danych do przekazania komponentowi
    wykresu. Jeżeli poprzeni i nowy zakres danych się różni - następuje właściwa wymiana danych w komponencie.
</p>

<h3>Synchronizacja</h3>

<p>
    Moduł <em>DynamicProjection</em>, oprócz reagowania na ruch użytkownika, reaguje na każdą zmianie w pamięci, która
    dotyczy fragmentu przesłanego do komponentu wykresu.

    Realizuje to poprzez nasłuchiwanie odpowiedniej projekcji pamięci podręcznej na interesującym zakresie (zob. <a
        href="#chapter:implementation-projection-recalculation"></a>).
    W momencie, gdy wyniku interakcji użytkownika nastąpi zmiana poziomu szczegółowości danych,
    <em>DynamicProjection</em> przełącza się na nasłuchiwanie odpowiadającej temu poziomowi projekcji.
    Dzięki temu komponenty będzie aktualizowany zmianami w <em>cache</em> tylko tymi, które jego naprawdę dotyczą.
    Przełączanie na inny <em>CacheProjection</em> zostało zilustrowane na rysunku <a
        href="#picture:dynamic-projection"></a> w
    postaci styku obrotowego znajdującego się wewnątrz <em>DynamicProjection</em>.
</p>

<h2 id="chapter:rangescopedevent">Zakresowy model zdarzeniowy</h2>

<p>
    Nasłuchiwanie zmian projekcji w określonym zakresie zostało zrealizowane poprzez zaimplementowanie prostego modelu
    zdarzeniowego, nieznacznie różniącego się od klasycznego modelu zdarzeniowego. Otóż dla każdego zdarzenia definiuje
    się jego zasięg <q>słyszalności</q> w postaci zakresu określonego typem <em>Range</em> (zob. rozdział <a
        href="#chapter:rangealgebra"></a>).
    Nasłuchiwanie zdarzenia również pozwala na określenie zakresu, na którym nasłuchiwanie ma się odbywać.
    Przykład użycia został pokazany na listingu <a href="#code:rangescopedevent"></a>.
</p>

<figure type="code" id="code:rangescopedevent">
    <figcaption>Przykład użycia <em>RangeScopedEvent</em></figcaption>
    <pre><code class="javascript">
const event = new RangeScopedEvent();
// dodawnie listenerów przez DynamicProjection
event.addListener('update', Range.leftClosed(0, 1), () => print('A!'));
event.addListener('update', Range.unbounded(), () => print('B!'));
event.addListener('update', Range.opened(1,2), () => print('C!'));
// uruchomienie zdarzenia przez ProjectionCache
event.fireEvent('update', Range.unbounded()) // A! B! C!
event.fireEvent('update', Range.closed(1, 2)) // B! C!
event.fireEvent('update', Range.opened(100,200)) // B!
event.fireEvent('update', Range.rightClosed(-1,0)) // A! B!
    </code></pre>
</figure>

<p>
    Podczas wywoływania zdarzenia ograniczonego czasem wywoływane są tylko te obiekty nasłuchujące, których zakres
    nasłuchiwania ma część wspólną z zakresem zdarzenia &mdash; po prostu są w stanie siebie <q>usłyszeć</q>.
</p>


<h2 id="chapter:implementation-adapter">Adapter komponentu wykresu</h2>
<p note="chodzi o wykresy i ich aktualizacje oraz interfejsy <q>patch</q> (visjs) i <q>replace</q> (flot)">
    (pseudokod adaptera?)
</p>

<!--

TODO: rozważanie o sposobie powiadamiania klienta o zmianach danych
<ul>
    <li>powiadomienie, że gdzieś coś się zmieniło, wtedy użytkownik albo sam robi diffa, albo resetuje komponent
        wykresów. to może powodować bad UX, migotanie, itd
    </li>
    <li>powiadomienie o dokładnych zmianach. instrukcja co krok po kroku należy zmienić, aby przejść ze stanu obecnego
        do wyjsciowego. minimalizacja liczby kroków.
        Jaki fragment danych z wykresu usunąć ( z jakiej warstwy).
        Jaki fragment danych z wykresu poszerzyć (z jakiej warstwy).
        Jaki fragment do danych z wykresu dodać (z jakiej warstwy).
        Common pattern byłby taki, że albo każda seria to inna warstwa, albo jedna seria ma punkty ze wszystkich warstw.
    </li>
</ul>
<figure type="code">
    <code class="javascript">
        class ExampleZingAdapter extends ClientProxyAdapter{
        processChange(diff) {
        // diff.added, diff.removed, diff.resized -- > {layer:[Number], start, end}
for(var removedRange of diff.removed){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
for(var addedRange of diff.added){
this.chart.getSerie(this.getSerieIndex(addedRange.layer).remove(addedRange.start, addedRange.end)
}
}
}
</code>
</figure>
-->


<p helper="">
    problemy implementacyjne https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_27
</p>


<h2>Wraper dla agregacji</h2>

<!--
Konieczność wrapperdisplay cache i translacja data-projection-data

implementacja: Skale zwyczajowe (użytkowe np dzień 12, tydzień 53, miesiąc, etc) nie robią problemu u mnie, bo każda
            agregacja ma parametr czas otwarcia i czas zamknięcia okresu który reprezentują. Żadną agregacja nie musi
            być wielokrotnościa poprzedniej, bo punkty agregacji są niezależne pomiędzy warstwami.
            Dopiero CacheProjection dobiera sobie agregację do zakresów czasu, ale znowu, każda agregacja ma wpisany
            czas za który odpowiada.
-->

<h2>Problemy z integracją z bibliotekami</h2>
<ul>
    <li>ZingChart
        * obfuscowany kod, debugging, errory...
        * beznadziejne API globalnych komend, nie da się niektórych rzeczy łatwo uzyskać ustawić
        * chyba wypełniad dziury między date.getTime() a date.getTime() co trwa bardzo długo... alokacja kilkadziesiat sekund - nie można przyczyny normalnie zdebugować
        * brak normalnego pan&zoom
        * jakieś dziwne przeliczenia iteracja po dziedzinie co "1" - od jednej daty do drugiej może minąć dużo czasu -
        to jednoznacznie dyskwalifikuje - dzieje się to w momencie gdy następuje zmiana zakresu wyświetlanego
    </li>
</ul>
<h2>Wykorzystane narzędzia i środowiska</h2>

<p helper="prezentacja 2">
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_39
</p>
<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

</p>

<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>



<h2>Modele predykcji</h2>

<p note="zaimplementowane modele predykcji" helper>
    implementacja: prediction models i dynamicProjection - paddingi, <strong>tiles</strong> muszą być sensownie dopasowane,
    żeby np wykres nie byl co chwile przerysowany, bo jakis drobnostkowy model predykcji co chwile aktualizuje
    mały kawałeczek

    opisać kafelkowanie zakresu danych takie jak w DynamicProjection (żeby predyktor nie doładowywał małych słupków
    podczas smooth paningu
</p>
