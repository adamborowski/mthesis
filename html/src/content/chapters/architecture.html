<!--suppress HtmlUnknownTag -->
<h1 id="chapter:solution">Architektura biblioteki ExploreJS</h1>

<p>
    Proponowanym w tej pracy rozwiązaniem, mającym na celu zminimalizowanie czasu oczekiwania na dane w wizualnej
    eksploracji
    danych pomiarowych, jest niżej przedstawiona i omówiona biblioteka napisana w języku <em>JavaScript</em>, której
    zadaniem jest sprawnie dostarczać
    dane końcowemu użytkownikowi, oglądającemu je na wykresie.
    W celu identyfikacyjnym zostało ono nazwane <em>ExploreJS</em>.
</p>
<p>
    Na wstępie warto przedstawić, czym jest <q>istniejący system</q> oraz w którym jego miejscu zostanie zastosowane
    proponowane rozwiązanie. Na diagramie <a href="#picture:architecture-overview"></a> pokazano miejsce w systemie, w
    którym działa <em>ExploreJS</em>.
</p>


<figure type="picture" id="picture:architecture-overview">
    <figcaption>Ogólny zarys systemu używającego <em>ExploreJS</em></figcaption>
    <img src="cache/architecture-existing-system.png"/>
</figure>

<p>
    System posiada architekturę <em>klient-serwer</em>, gdzie klientem jest aplikacja działająca w przeglądarce
    internetowej, a serwerem aplikacja serwująca dane pomiarowe. Klient i serwer jest połączony siecią lokalną lub
    siecią Internet.
</p>

<p>
    Baza danych może być fizycznie zlokalizowana na tej samej maszynie co serwer lub innej.
    W drugim przypadku dane często są replikowane na serwerze danych w celu optymalizacji czasu odpytywania bazy danych
    i zrównoważenia obciążenia całego systemu.
    Baza danych jest przygotowana do serwowania danych pomiarowych tych surowych jak i tych odpowiednio zagregowanych.
</p>

<p>
    Może się zdarzyć, że system działa w oparciu o różne standardy komunikacyjne.
    W takim przypadku najczęściej tworzy się dodatkowy serwis, który będzie udostępniał dane w protokole
    <em>HTTP</em> w formacie <em>JSON</em>, gdyż to jest główny protokół i format obsługiwany przez przeglądarki.
    Dodatkowy serwis może być stworzony również po to, by nie umieszczać we właściwym serwerze logiki niezbędnej do
    pracy <em>ExploreJS</em>, jak na przykład <em>manifest danych</em>, opisany w rozdziale <a
        href="#chapter:implementation"></a>.
    Może się tak zdarzyć zwłaszcza wtedy, gdy z różnych względów nie ma możliwości modyfikacji implementacji właściwego
    serwera danych.
</p>

<p>
    W takim systemie końcowy użytkownik korzysta z systemu za pomocą aplikacji uruchamianej w przeglądarce.
    Aplikacja ta posiada funkcję eksploracji danych, która wykorzystuje dowolną bibliotekę JavaScript rysującą wykresy
    i wyświetla wykresowy komponent interfejsu użytkownika na ekranie.
</p>

<p>
    Moduł aplikacji odpowiedzialny za eksplorację danych obsługuje interakcję z wykresem.
    Najczęściej nasłuchuje zdarzenia dostarczane przez dany komponent wykresowy dotyczące zmiany zakresu wyświetlanych
    danych (na skutek interakcji z
    użytkownikiem). W reakcji na to zdarzenie
    informacja o zmianie wyświetlanego zakresu przekazywana jest do modułu biblioteki <em>ExploreJS</em>.
</p>

<p>
    Sam moduł biblioteki <em>ExploreJS</em> komunikuje się bezpośrednio z serwisem <em>REST</em> oraz przekazuje dane do
    modułu aplikacji, która aktualizuje punkty na wykresie.
</p>

<p>
    Biblioteka <em>ExploreJS</em> jest zatem swego rodzaju pamięcią podręczną <trans lang="ang">cache</trans> dla danych pomiarowych, która
    pośredniczy między komponentem wykresowym w aplikacji a danymi na serwerze.
</p>

<h2>Asynchroniczny przepływ informacji</h2>

<p>
    Pierwszą kwestią dotyczącą konstrukcji rozwiązania jest asynchroniczny model komunikacji.
    Typowe podejście zakłada raczej komunikację synchroniczną typu żądanie-odpowiedź: <q>zmienił się zakres
    wyświetlanych danych &mdash; następuje pobranie nowych danych do wyświetlenia</q>.
    Tutaj jednak zaproponowano bardziej elastyczne rozwiązanie, w którym jedynym zobowiązaniem aplikacji względem
    <em>ExploreJS</em> jest:
</p>
<ul>
    <li><em>powiadomienie</em>, kiedy zdarzyła się zmiana zakresu wyświetlanych danych,</li>
    <li><em>przerysowanie</em> wykresu na każde żądanie <em>ExploreJS</em>.</li>
</ul>

<p class="keep-before">
    Ważne jest to, że między dwoma powyższymi nie ma bezpośredniej zależności czasowej.
    Dzięki tej elastyczności biblioteka <em>ExploreJS</em> może sama decydować, kiedy i jakimi danymi aktualizować
    wykres. Na diagramie <a href="#picture:architecture-async-calls"></a> pokazano przykładową sekwencję odwołań
    pomiędzy poszczególnymi elementami systemu.
</p>


<figure type="picture" id="picture:architecture-async-calls">
    <figcaption>Przykładowa sekwencja komunikacji w <em>ExploreJS</em></figcaption>
    <img src="cache/architecture-async-calls.png"/>
</figure>

<p>
    Analizując powyższy diagram z punktu widzenia modułu <em>ExploreJS</em>, może się zdarzyć tak jak przy pierwszej
    zmianie
    zakresu, gdzie powstała konieczność doładowania kawałka danych, ale w międzyczasie <em>ExploreJS</em> przekazuje te
    dane, które ma już w pamięci podręcznej.
    Z kolei przy drugiej zmianie zakresu wszystkie dane były dostępne w pamięci cache, zatem przekazuje od razu porzebne
    dane.
    Przy trzeciej, czwartej i piątej zmienie zakresu nie tylko nie istnieje potrzeba doładować dane, ale nawet nie
    trzeba aktualizować wykresu, ponieważ w danym momencie posiada dane dla wszystkich trzech zakresów.
    Jest to związane z własnością większości bibliotek wykresowych opisanych w rozdziale <a
        href="#chapter:web-interfaces"></a>, gdzie dany wykres może w swojej pamięci posiadać więcej danych, niż w danej
    chwili widać na ekranie.
</p>

<p note="wskazać asynchroniczność view change - chart update, bo to kiedy aktualizaować, lepiej wie biblioteka, nie zawsze gdy jest zmiana requesta">
    chapter:web-interfaces - napisac ze rozwiazanie aktualizuje kawalek na wykresie, ale z reguly wiekszy niz ten co
    widac, i jest to mozliwe
</p>


<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

    Zaprojektowanie architektury modułu pamięci podręcznej, w tym przedstawienie struktury danych
    wspierającej fragmentację czasową oraz fragmentację skali danych

    Zaprojektowanie architektury modułu predykcji

</p>
<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>
<figure type="picture" id="picture:architecture">
    <figcaption>Architektura</figcaption>
    <img src="cache/client-architecture.png">
</figure>

<h2>Serwer danych</h2>
<p>
    Serwer danych powinien być minimalnie zależny od proponowanego rozwiązania, gdyż jest to część "wymienna" systemu.
    Zatem jego zadaniem będzie tylko zwracanie danych określonych prostym formatem zapytania.
</p>
<h2>Komponent użytkownika</h2>
<p>
    Jest to dowolny moduł programowy, którego celem jest wyświetlanie danych pomiarowych.
    Jego wewnętrzna postać oraz zachowanie są zupełnie niezależne od przedstawianego rozwiązania.
    Przez pojedynczy komponent rozumie się pojedynczą serię danych. Jeśli komponent wykresu wyświetla wiele serii na
    wspólnym obszarze, z punktu widzenia proponowanego rozwiązania należy każdą serię rozpatrywać osobno.
</p>
<ul data-header="Przykładowe komponenty użytkownika, to m. in.:">
    <li><a href="http://www.highcharts.com/">High Charts</a></li>
    <li><a href="http://www.zingchart.com/">Zing Chart</a></li>
    <li><a href="http://d3js.com/">d3.js</a></li>
</ul>
<h2>Data Source</h2>
<p>
    Moduł DataSource umożliwia integrację przedstawianego rozwiązania z dowolnym komponentem użytkownika poprzez
    udostępnianie mu dynamicznych danych.
    Definiuje on standard emisji zdarzeń dotyczących dostępności danych.
    Przykładowo, emituje zdarzenie o pojawieniu się nowego fragmentu danych na określonym poziomie abstrakcji.
    Moduł ten sam jednak nie jest przystosowany do współpracy z konkretnym komponentem. Jest to jednolity interfejs
    systemu dostarczony programistom.
</p>
<h2>Adapter DataSource</h2>
<p>
    Adapter ten implementuje interfejs dostępu do danych <i>DataSource</i>.
    Podłącza dedykowany komponent użytkownika do <i>DataSource</i>.
    Jego zadaniem jest reagowanie na zdarzenia DataSource i określenie reakcji po stronie komponentu.
    Przykładem może być reakcja na zdarzenie pojawienia się nowego fragmentu danych wyrażona poprzez zmodyfikowanie
    specyficznej dla Komponentu struktury danych oraz żądania przerysowania całości (lub części) wykresu.
</p>
<p>
    Na listingu <a href="#code:example-data-source-adapter"></a> pokazano przykładową implementację adaptera, który w
    metodzie <i>onTileAvailable</i> aktualizuje stan pewnego komponentu:
</p>
<ol>
    <li>
        Usuwane są wszystkie punkty z okresu odpowiadającego danemu kafelkowi. Takie punkty mogły pochodzić fragmentu
        kafelka o mnieszej rodzielczości,
    </li>
    <li>
        Dodawane są wszystkie punkty z nowego kafelka,
    </li>
    <li>
        Nowe punkty są przekształcane do formatu wyznaczonego przez komponent użytkownika.
    </li>
    <li>
        Aktualizacja widoku użytkownika umożliwiająca interakcję systemu z komponentem.
    </li>
</ol>
<figure type="code" id="code:example-data-source-adapter">
    <figcaption>Poglądowa implementacja adaptera DataSource</figcaption>
    <code class="javascript">
        class ExampleChartsAdapter extends DataSourceAdapter {
            onTileAvailable (tile) {
                this.chart.getSerie(this.serieId).removeDataForRange(tile.range.start, tile.range.end); // 1.
                this.chart.getSerie(this.serieId).addData( // 2.
                    tile.points.map((p) => {
                        return { x: new Date(p.time), y: p.value, color: this.colors[p.attr.status] } // 3.
                    }
                );
            }

            onRedraw () {
                this.chart.redraw();
            }

            init () {
                this.chart.on('move', () => this.updateUserState({ // 4.
                    'viewport.center.x': this.chart.center.x,
                    'viewport.center.y': this.chart.center.y
                }));
                this.chart.on('resize', () => this.updateUserState({
                    'viewport.width': this.chart.size.width,
                    'viewport.height': this.chart.size.height
                }));
            }
        }
</code>
</figure>

<p helper>
    projektować od najprostrzej strony, czyli formacie zapytania i odpowiedzi klient-serwer
    zaimplementować protokół klient serwer
    zaimplementować serwer, dane mogą być w pamięci, whatever (można tez zrobic import z wios???)
    rozpisać SerieCache na CacheLayer, CacheProjection (kompiluje warstwy) - opisać "przejścia stanów", tj że jeżeli na
    zoom=4 pojawia się kafel danych, to CacheProjection zobaczy to poprzez usunięcie fragmentu tile o zoom=3 i dodanie
    danych dla zoom = 4. Może coś takiego jak event listeners for time range, wtedy jeden CacheProjection nasłuchuje na
    "stożek" eventów.
    Nasłuchuje eventy na kazdej warstwie, ale tylko na wybranym obszarze. Wtedy listenery są przechowywane w jakimś
    sorted tree, aby łatwiej odnajdywać które listenery odpalić. może jakiś BST albo coś...

    CacheProjection powinno dotyczyć jednego DataSource (dobór levelu w zależności od zooma - nie za szczegółowe mimo ze
    beda dostepne)
</p>