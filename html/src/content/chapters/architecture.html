<!--suppress HtmlUnknownTag -->
<h1 id="chapter:solution">Architektura biblioteki ExploreJS</h1>

<p>
    Proponowanym w tej pracy rozwiązaniem, mającym na celu zminimalizowanie czasu oczekiwania na dane w wizualnej
    eksploracji
    danych pomiarowych, jest niżej przedstawiona i omówiona biblioteka napisana w języku <em>JavaScript</em>, której
    zadaniem jest sprawnie dostarczać
    dane końcowemu użytkownikowi, oglądającemu je na wykresie.
    W celu identyfikacyjnym zostało ono nazwane <em>ExploreJS</em>.
</p>
<p>
    Na wstępie warto przedstawić, czym jest <q>istniejący system</q> oraz w którym jego miejscu zostanie zastosowane
    proponowane rozwiązanie. Na diagramie <a href="#picture:architecture-overview"></a> pokazano miejsce w systemie, w
    którym działa <em>ExploreJS</em>.
</p>


<figure type="picture" id="picture:architecture-overview">
    <figcaption>Ogólny zarys systemu używającego <em>ExploreJS</em></figcaption>
    <img src="cache/architecture-existing-system.png"/>
</figure>

<p>
    System posiada architekturę <em>klient-serwer</em>, gdzie klientem jest aplikacja działająca w przeglądarce
    internetowej, a serwerem aplikacja serwująca dane pomiarowe. Klient i serwer jest połączony siecią lokalną lub
    siecią Internet.
</p>

<p>
    Baza danych pomiarowych może być fizycznie zlokalizowana na tej samej maszynie co serwer lub innej.
    W drugim przypadku dane często są replikowane na serwerze danych w celu optymalizacji czasu odpytywania bazy danych
    i zrównoważenia obciążenia całego systemu.
    Baza danych jest przygotowana do serwowania danych pomiarowych surowych jak i tych odpowiednio zagregowanych.
</p>

<p>
    Może się zdarzyć, że system działa w oparciu o różne standardy komunikacyjne.
    W takim przypadku najczęściej tworzy się dodatkowy serwis, który będzie udostępniał dane protokołem <em>HTTP</em> w
    formacie <em>JSON</em>, gdyż to jest główny protokół i format obsługiwany przez przeglądarki.
    Dodatkowy serwis może być stworzony również po to, by nie umieszczać we właściwym serwerze logiki niezbędnej do
    pracy <em>ExploreJS</em>, jak na przykład <em>manifest danych</em>, opisany w rozdziale <a
        href="#chapter:implementation"></a>.
    Może się tak zdarzyć zwłaszcza wtedy, gdy z różnych względów nie ma możliwości modyfikacji implementacji właściwego
    serwera danych.
</p>

<p>
    W takim systemie końcowy użytkownik korzysta z systemu za pomocą aplikacji uruchamianej w przeglądarce.
    Aplikacja ta posiada funkcję eksploracji danych, która wykorzystuje dowolną bibliotekę JavaScript rysującą wykresy
    i wyświetla wykresowy komponent interfejsu użytkownika na ekranie.
</p>

<p>
    Moduł aplikacji odpowiedzialny za eksplorację danych obsługuje interakcję z wykresem.
    Najczęściej nasłuchuje zdarzenia dostarczane przez dany komponent wykresowy dotyczące zmiany zakresu wyświetlanych
    danych (na skutek interakcji z
    użytkownikiem). W reakcji na to zdarzenie
    informacja o zmianie wyświetlanego zakresu przekazywana jest do modułu biblioteki <em>ExploreJS</em>.
</p>

<p>
    Sam moduł biblioteki <em>ExploreJS</em> komunikuje się bezpośrednio z serwisem <em>REST</em> oraz przekazuje dane do
    modułu aplikacji, która aktualizuje punkty na wykresie.
</p>

<p>
    Biblioteka <em>ExploreJS</em> jest zatem swego rodzaju pamięcią podręczną <trans lang="ang">cache</trans> dla danych pomiarowych, która
    pośredniczy między komponentem wykresowym w przeglądarce a danymi na serwerze.
</p>

<h2>Asynchroniczny przepływ informacji</h2>

<p>
    Pierwszą kwestią dotyczącą konstrukcji rozwiązania jest asynchroniczny model komunikacji.
    Typowe podejście zakłada raczej komunikację synchroniczną typu żądanie-odpowiedź: <q>zmienił się zakres
    wyświetlanych danych &mdash; następuje pobranie nowych danych do wyświetlenia</q>.
    Tutaj jednak zaproponowano bardziej elastyczne rozwiązanie, w którym jedynym zobowiązaniem aplikacji względem
    <em>ExploreJS</em> jest:
</p>
<ul>
    <li><em>powiadomienie</em>, kiedy zdarzyła się zmiana zakresu wyświetlanych danych,</li>
    <li><em>aktualizacja</em> komponentu wykresowego na każde żądanie <em>ExploreJS</em>.</li>
</ul>

<p class="keep-before">
    Ważne jest to, że między dwoma powyższymi nie ma bezpośredniej zależności czasowej.
    Dzięki tej elastyczności biblioteka <em>ExploreJS</em> może sama decydować, kiedy i jakimi danymi aktualizować
    wykres. Na diagramie <a href="#picture:architecture-async-calls"></a> pokazano przykładową sekwencję odwołań
    pomiędzy poszczególnymi elementami systemu.
</p>


<figure type="picture" id="picture:architecture-async-calls">
    <figcaption>Przykładowa sekwencja komunikacji w <em>ExploreJS</em></figcaption>
    <img src="cache/architecture-async-calls.png"/>
</figure>

<p>
    Analizując powyższy diagram z punktu widzenia modułu <em>ExploreJS</em>, może się zdarzyć tak jak przy pierwszej
    zmianie
    zakresu, gdzie powstała konieczność doładowania kawałka danych, ale w międzyczasie <em>ExploreJS</em> przekazuje te
    dane, które ma już w pamięci podręcznej.
    Z kolei przy drugiej zmianie zakresu wszystkie dane były dostępne w pamięci cache, zatem przekazuje od razu porzebne
    dane.
    Przy trzeciej, czwartej i piątej zmienie zakresu nie tylko nie istnieje potrzeba doładować dane, ale nawet nie
    trzeba aktualizować wykresu, ponieważ w danym momencie posiada dane dla wszystkich trzech zakresów.
    Jest to związane z własnością większości bibliotek wykresowych opisanych w rozdziale <a
        href="#chapter:web-interfaces"></a>, gdzie dany wykres może w swojej pamięci posiadać więcej danych, niż w danej
    chwili widać na ekranie.
</p>

<h2> Wielowarstwowa pamięć podręczna</h2>

<p>
    Kluczowym elementem rozwiązania jest <em>wielopoziomowa pamięć cache</em>, której celem jest zapamiętanie
    odwiedzonych przez użytkownika danych, by w momencie powtórnego ich odwiedzenia nie było konieczności ponownego
    wysyłania zapytania do serwera.
    Przechowuje ona agregacje danych pomiarowych na różnych warstwach pamięci w ten sposób, że dane o tym samym poziomie
    agregowania są przechowywane
    na tej samej warstwie.
</p>
<p>
    Taką organizację pamięci można porównać do regału na książki, gdzie na każdej półce leżą książki o tej samej
    grubości.
    Lekkie książki leżą na górze regału, natomiast najgrubsze będą usytuowane na samym dole. Zostało to zilustrowane na
    obrazku <a href="#picture:cache3d-full"></a>.
</p>

<figure type="picture" id="picture:cache3d-full">
    <figcaption>
        Wizualizacja wielopoziomowej pamięci danych pomiarowych.
        Na najwyższej warstwie leżą najmniejsze agregacje (15 jedn. czasu), na samym dole największe (360 jedn. czasu).
    </figcaption>
    <img src="/images/theoretical/multilevecache-full.png"/>
</figure>

<p>
    Istotnym faktem jest to, że pamięć podręczna niejako z natury nie zawiera wszystkich dostępnych danych, lecz tylko
    te, do których dostęp był wcześniej żądany. Można zatem mówić o fragmentacji pamięci <em>cache</em>, na każdej
    warstwie pamięci.
    Zostało to zilustrowane na obrazku <a href="#picture:cache3d-missing"></a>.
</p>

<figure type="picture" id="picture:cache3d-missing">
    <figcaption>
        Wizualizacja fragmentacji danych w wielowarstwowej pamięci cache.

    </figcaption>
    <img src="/images/theoretical/multilevelcache-missing.png"/>
</figure>

<p>
    Kiedy następuje wyświetlenie określonego zakresu czasu na wykresie, do pamięci cache trafia żądanie o konkretne
    agregacje danych w tym zakresie. Mogą być to przykładowo <q>agregacje miesięczne od maja 2010 roku do lipca 2017
    roku</q>. W takim przypadku z <q>półki</q> z agregacjami miesięcznymi zostają odczytane wszystkie dostępne agregacje
    miesięczne od maja 2017 do lipca 2017 włącznie. Jeżeli brakuje jakiś danych, to pamięć zwraca pofragmentowane dane,
    a brakujące dane będą doładowane później.
</p>

<h2>Projekcja warstw cache</h2>

<p>
    Mimo wspomnianej niezależności warstw pamięci cache, pomiędzy danymi z różnych warstw zachodzą bardzo mocne związki.
    Otóż agregacje z <q>niższych pięter</q> reprezentują te same dane co ich wyższe odpowiedniki.
    Różnica polega na stopniu dokładności.
    Niższa warstwa jest pewnym uproszczeniem wyższej.
</p>
<p>
    Warto sobie uświadomić, że bardzo często się zdarza, iż pamięć cache w danej chwili nie posiada żądanych agregacji,
    ale dysponuje ich mniej dokładnymi odpowiednikami.
</p>
<p>
    <em>ExploreJS</em> wykorzystuje tę zależność w celu zmaksymalizowania użycia danych z pamięci cache. To znaczy, że
    zamiast wyświetlać <q>dziury</q> na wykresie w miejscu, gdzie chwilowo brakuje danych, wykorzysta mniej dokładne
    agregacje z cache i wyświetli je w miejsce wspomnianej <q>dziury</q>.
    Takie progresywne wyświetlanie danych wykorzystuje ludzką percepcję czasu (opisaną w rozdziale <a
        href="#chapter:ux"></a>) do skrócenia postrzeganego czasu odpowiedzi systemu.
</p>

<p>
    Aby wyświetlić użytkownikowi dane w sposób progresywny, gdzie będą sąsiadowały fragmenty o mniejszej i większej
    dokładności, należy dane z różnych poziomów cache w jakiś sposób ze sobą złączyć.
    Należy zwrócić uwagę, że przy złączeniu poziomów, dane z różnych warstw mogą ze sobą kolidować, na przykład
    agregacja dobowa z dnia 24 sierpnia 2017 roku będzie kolidowała z dostępnymi agregacjami godzinowymi z tego samego
    dnia, ale też na przykład z agregacją miesięczną z sierpnia 2017 oraz agregacją roczną z roku 2017.
</p>

<p>
    Jeżeli w powyższej sytuacji optymalnym do wyświetlania na wykresie poziomem agregacji jest doba, to podczas
    łączenia warstw nie powinno się brać pod uwagę warstw mniejszych agregacji, ponieważ nie będą widoczne na ekranie
    (nałożą się na jeden piksel).
    W związku z tym wspomniane wyżej agregacje godzinne będą ignorowane podczas łączenia warstw.
</p>

<p>
    Sposobem łączenia danych, który optymalnie rozwiązuje te konflikty, jest projekcja warstw, która redukuje je do
    jednej, widocznej na ekranie, warstwy.
    Jest to projekcja analogiczna do projekcji trójwymiarowego modelu na dwuwymiarowy obraz - elementy bliżej kamery
    będą przysłaniały te bardziej oddalone.
</p>
<p>
    Taką projekcję można porównać do obserwowania wspomnianego regałum z książkami, ale nie z perspektywy pokazanej na
    ilustracji <a href="#picture:cache3d-missing"></a>, lecz z góry, patrząc w dół.

    Jeśli założyć, że regał jest dwuwymiarowy (posiada wysokość i szerokość), to projekcja zrzutowałaby wszystkie
    książki z każdej półki na jedną wspólną półkę.

    Pokazane zostało to na ilustracji <a href="#picture:cache3d-projection"></a>.
    Punkt A pokazuje rzut z boku <q>regału</q>, gdzie widać stan pamięci cache, punkt C natomiast pokazuje rzut z góry
    <q>regału</q>, czyli to co widzi użytkownik na ekranie. Punkt B pokazuje rzut pośredni, w którym można zobaczyć, jak
    poszczególne warstwy się przysłaniają podczas projekcji.
</p>

<figure type="picture" id="picture:cache3d-projection">
    <figcaption>
        Rzutowanie danych z różnych warstw pamięci cache. A - widok z boku, B - widok ukośny, C - widok z góry
        (projekcji). Strzałką zaznaczono przykładowe agregacje przed, w trakcie oraz po projekcji.
    </figcaption>
    <img src="cache/cache3d-projection.png"/>
</figure>

<p>
    Widać tutaj, że agregacje z żądanej warstwy <em>czerwonej</em> pojawiły się w całości na ekranie <em>(punkt C)</em>.
    Miejsca, w których nie było dostępnych agregacji <em>czerwonych</em>, uzupełniono fragmentami z <q>cięższej</q>
    warstwy <em>niebieskiej</em>.
    Następnie, miejsca, w których nie było dostępnych ani <em>czerwonych</em> ani <em>niebieskich</em> agregacji,
    uzupełniono fragmentami z jeszcze <q>cięższej</q> warstwy <em>żółtej</em>.
    Następnie, miejsca, w których nie było dostępnych ani <em>czerwonych</em>, ani <em>niebieskich</em>, ani
    <em>żółtych</em> agregacji, uzupełniono fragmentami z <q>najcięższej</q> warstwy, <em>zielonej</em>.
    W tym momencie, zostały jeszcze miejsca, w których nie znaleziono danych w żadnej warstwie, w związku z czym w
    takich miejscach powstała <q>dziura</q> niepokryta żadnymi agregacjami.
</p>

<p>
    Oczywiście taka sytuacja, kiedy wyświetlane są dane z niższych warstw, jest chwilowa, do czasu załadowania
    właściwych agregacji. W praktyce łączenie warstw użytkownik widzi w ten sposób, jak na ilustracji <a
        href="#picture:projection-chart"></a>.
</p>

<figure type="picture" id="picture:projection-chart">
    <figcaption>
        Wykres zawierający agregacje z dwóch różnych warstw.
        Gdyby nie zastosować projekcji, mniej wyraźna cześć wykresu była by po prostu pusta.
    </figcaption>
    <img src="/images/theoretical/projection.png"/>
</figure>


<h2> Silnik predykcji</h2>

<p>
    Elementem ściśle współpracującym z pamięcią <em>cache</em> jest silnik predykcji, który bezpośrednio ją odpytuje i
    wpływa na jej uzupełnianie.

    Jego zadaniem jest takie przygotowanie pamięci, by w momencie, gdy zostanie ona zapytana przez wykres w celu
    wyświetlenia danych, zapewnić mu maksymalną dostępność tych danych.
</p>

<p>
    Silnik predykcji opiera swoje działanie na modelach predykcji, które są jego integralną częścią.
    Każdy model predykcji działa niezależnie, ma swój określony cel i odrębnie zaimplementowaną logikę odpytywania pamięci
    podręcznej. W uproszczeniu model predykcji obserwuje interakcję użytkownika z wykresem, próbuje
    wywnioskować, jakie dane powinny znaleźć się w pamięci <em>cache</em> i jak szybko powinny być dostepne, następnie w
    odpowiednim momencie odpytuje pamięć <em>cache</em> by zapewnić ich dostępność.
</p>

<h2>Schemat rozwiązania</h2>

<p CLASS="keep-after">
    W tej części zostanie przedstawione, jak zaprojektowana została biblioteka <em>ExploreJS</em>, z jakich modułów
    się składa. Poglądowy schemat rozwiązania został przedstawiony na diagramie <a
        href="#picture:architecture-simple"></a>.
</p>
<figure type="picture" id="picture:architecture-simple">
    <figcaption>Koncepcyjny schemat <em>ExploreJS</em></figcaption>
    <img src="cache/architecture-overview.png">
</figure>

<p>
    Dokładniejszy schemat i opis działania został omówiony w rozdziale <a href="#chapter:implementation"></a>.
    W ogólności <em>ExploreJS</em> składa się z sześciu cześci, z której każda odpowiada za inną funkcję rozwiązania.
</p>

<p>
    Moduł <em>RequestManager</em> odpowiada za zarządzanie komunikacją z serwerem <em>REST</em>. Przyjmuje zgłoszenia
    zapotrzebowania na dane w określonym zakresie czasu i poziomie agregacji. Jego zadaniem jest optymalizacja
    procesu wysyłania żądań do serwera, w szczególności grupowanie ich w paczki w celu minimalizacji liczby
    jednoczesnych
    zapytań do serwera.
    Po otrzymaniu odpowiedzi przekazuje dane do kolejnych modułów.
</p>

<p>
    Moduł <em>DataCache</em> odpowiada za przechowywanie agregacji danych pomiarowych w usystematyzowany sposób.
    Zarządza wielowarstwową strukturą danych, w której to na każdej warstwie przechowuje dane z innego poziomu
    agregacji.
    Ponieważ jest to pamięć typu <em>Cache</em>, jej zadaniem jest również wygenerowanie odpowiedniego żądania do modułu
    <em>RequestManager</em> w przypadku stwierdzenia braku fragmentu danych w momencie odpytywania tej pamięci.
</p>

<p>
    Moduł <em>ProjectionCache</em> jest to indeks projekcji pamięci podręcznej, który przechowuje informacje związane z
    projekcją danych, towarzyszące każdej warstwie pamięci.
    Dla każdej warstwy pamięci bowiem jest zapisane, jak wygląda projekcja niższych warstw na tę warstwę.
    Zostało to pokazane na przykładzie na ilustracji <a href="#picture:projection-and-cache"></a>.
    Dla przykładu, na warstwie <q>4h</q> pamięci <em>cache</em>, przechowującej agregacje o długości czterech godzin,
    dostępne są dane w dwóch
    zakresach pokazanych żółtym kolorem.
    Natomiast odpowiedni dla tej warstwy indeks projekcji zawiera nie tylko dwa <em>żółte zakresy</em>, ale fragmenty
    pomarańczowe, czerwone i różowe, powstałe w wyniku przysłaniania warstw podczas projekcji niższych warstw.
    Indeks projekcji jest aktualizowany dla każdej warstwy w momencie pobrania nowych danych do pamięci podręcznej, w
    związku z tym jest bardzo szybki w odczycie.
    Indeks odpowiada na pytanie, z jakiej warstwy pamięci podręcznej należy pobrać dane w danym zakresie.
    Ilustrują to różnokolorowe segmenty, gdzie każdy kolor odzwierciedla inną warstwę w <em>cache</em> (ilustracja <a
        href="#picture:projection-and-cache"></a>).

    Aby przygotować do wyświetlenia dane złączone z różnych warstw <em>cache</em>,
    wystarczy odczytać indeks projekcji w danym zakresie, i dla każdego jego elementu odpytać pamięć podręczną dla
    poziomu agregacji i zakresu wskazanego przez dany element indeksu.
</p>

<p>
    Moduł <em>PredictionEngine</em> ...
</p>

<p>
    Moduł <em>DataSource</em> ...
</p>

<p note="tu napisać, że jest to customizowalny fragment data source">
    Moduł <em>ChartAdapter</em> ...
</p>

<figure type="picture" id="picture:projection-and-cache">
    <figcaption>Zależność między pamięcią podręczną, indeksem projekcji, adapterem i wyświetlanymi danymi.
        Można zauważyć, że kolejne warstwy indeksu projekcji powstają w wyniku nałożenia zakresów danych z pamięci <em>cache</em>
        danej warstwy na niższą warstwę indeksu.
    </figcaption>
    <img src="cache/projection-and-cache.png">
</figure>


<p helper="">
    cała Prezentacja 2
    założenia co do stanu "zastałego" - serwer API
    https://docs.google.com/presentation/d/1fgGbq1I2x5BQ2rY2zmWxnL5lVzEX9rD56j8435ydhn8/edit#slide=id.g111ad9752a_0_131

    Zaprojektowanie architektury modułu pamięci podręcznej, w tym przedstawienie struktury danych
    wspierającej fragmentację czasową oraz fragmentację skali danych

    Zaprojektowanie architektury modułu predykcji

</p>
<p>
    Architektura składa się ze ściśle ze sobą współpracujących modułów.
    Każdy z nich pełni ściśle określoną funkcję.
    Na rysunku <a href="#picture:architecture"></a> pokazano ogólny schemat zależności modułów.
    W kolejnych podrozdziałach zostały opisane funkcje poszczególnych modułów.
</p>
<figure type="picture" id="picture:architecture">
    <figcaption>Architektura</figcaption>
    <img src="cache/client-architecture.png">
</figure>

<h2>Serwer danych</h2>
<p>
    Serwer danych powinien być minimalnie zależny od proponowanego rozwiązania, gdyż jest to część "wymienna" systemu.
    Zatem jego zadaniem będzie tylko zwracanie danych określonych prostym formatem zapytania.
</p>
<h2>Komponent użytkownika</h2>
<p>
    Jest to dowolny moduł programowy, którego celem jest wyświetlanie danych pomiarowych.
    Jego wewnętrzna postać oraz zachowanie są zupełnie niezależne od przedstawianego rozwiązania.
    Przez pojedynczy komponent rozumie się pojedynczą serię danych. Jeśli komponent wykresu wyświetla wiele serii na
    wspólnym obszarze, z punktu widzenia proponowanego rozwiązania należy każdą serię rozpatrywać osobno.
</p>
<ul data-header="Przykładowe komponenty użytkownika, to m. in.:">
    <li><a href="http://www.highcharts.com/">High Charts</a></li>
    <li><a href="http://www.zingchart.com/">Zing Chart</a></li>
    <li><a href="http://d3js.com/">d3.js</a></li>
</ul>
<h2>Data Source</h2>
<p>
    Moduł DataSource umożliwia integrację przedstawianego rozwiązania z dowolnym komponentem użytkownika poprzez
    udostępnianie mu dynamicznych danych.
    Definiuje on standard emisji zdarzeń dotyczących dostępności danych.
    Przykładowo, emituje zdarzenie o pojawieniu się nowego fragmentu danych na określonym poziomie abstrakcji.
    Moduł ten sam jednak nie jest przystosowany do współpracy z konkretnym komponentem. Jest to jednolity interfejs
    systemu dostarczony programistom.
</p>
<h2>Adapter DataSource</h2>
<p>
    Adapter ten implementuje interfejs dostępu do danych <i>DataSource</i>.
    Podłącza dedykowany komponent użytkownika do <i>DataSource</i>.
    Jego zadaniem jest reagowanie na zdarzenia DataSource i określenie reakcji po stronie komponentu.
    Przykładem może być reakcja na zdarzenie pojawienia się nowego fragmentu danych wyrażona poprzez zmodyfikowanie
    specyficznej dla Komponentu struktury danych oraz żądania przerysowania całości (lub części) wykresu.
</p>
<p>
    Na listingu <a href="#code:example-data-source-adapter"></a> pokazano przykładową implementację adaptera, który w
    metodzie <i>onTileAvailable</i> aktualizuje stan pewnego komponentu:
</p>
<ol>
    <li>
        Usuwane są wszystkie punkty z okresu odpowiadającego danemu kafelkowi. Takie punkty mogły pochodzić fragmentu
        kafelka o mnieszej rodzielczości,
    </li>
    <li>
        Dodawane są wszystkie punkty z nowego kafelka,
    </li>
    <li>
        Nowe punkty są przekształcane do formatu wyznaczonego przez komponent użytkownika.
    </li>
    <li>
        Aktualizacja widoku użytkownika umożliwiająca interakcję systemu z komponentem.
    </li>
</ol>
<figure type="code" id="code:example-data-source-adapter">
    <figcaption>Poglądowa implementacja adaptera DataSource</figcaption>
    <code class="javascript">
        class ExampleChartsAdapter extends DataSourceAdapter {
            onTileAvailable (tile) {
                this.chart.getSerie(this.serieId).removeDataForRange(tile.range.start, tile.range.end); // 1.
                this.chart.getSerie(this.serieId).addData( // 2.
                    tile.points.map((p) => {
                        return { x: new Date(p.time), y: p.value, color: this.colors[p.attr.status] } // 3.
                    }
                );
            }

            onRedraw () {
                this.chart.redraw();
            }

            init () {
                this.chart.on('move', () => this.updateUserState({ // 4.
                    'viewport.center.x': this.chart.center.x,
                    'viewport.center.y': this.chart.center.y
                }));
                this.chart.on('resize', () => this.updateUserState({
                    'viewport.width': this.chart.size.width,
                    'viewport.height': this.chart.size.height
                }));
            }
        }
</code>
</figure>

<p helper>
    projektować od najprostrzej strony, czyli formacie zapytania i odpowiedzi klient-serwer
    zaimplementować protokół klient serwer
    zaimplementować serwer, dane mogą być w pamięci, whatever (można tez zrobic import z wios???)
    rozpisać SerieCache na CacheLayer, CacheProjection (kompiluje warstwy) - opisać "przejścia stanów", tj że jeżeli na
    zoom=4 pojawia się kafel danych, to CacheProjection zobaczy to poprzez usunięcie fragmentu tile o zoom=3 i dodanie
    danych dla zoom = 4. Może coś takiego jak event listeners for time range, wtedy jeden CacheProjection nasłuchuje na
    "stożek" eventów.
    Nasłuchuje eventy na kazdej warstwie, ale tylko na wybranym obszarze. Wtedy listenery są przechowywane w jakimś
    sorted tree, aby łatwiej odnajdywać które listenery odpalić. może jakiś BST albo coś...

    CacheProjection powinno dotyczyć jednego DataSource (dobór levelu w zależności od zooma - nie za szczegółowe mimo ze
    beda dostepne)
</p>